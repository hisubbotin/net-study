# Распространенные ошибки и вещи, на которые стоит обратить внимание

<!-- TOC -->

- [Распространенные ошибки и вещи, на которые стоит обратить внимание](#распространенные-ошибки-и-вещи-на-которые-стоит-обратить-внимание)
  - [01. Primitive Types](#01-primitive-types)
    - [TryParse + throw standard exception](#tryparse--throw-standard-exception)
    - [Compare floats with default epsilon](#compare-floats-with-default-epsilon)
  - [02. Adventure Time!](#02-adventure-time)
    - [AreEqualBirthdays](#areequalbirthdays)
    - [GetTotalMinutesInThreeMonths](#gettotalminutesinthreemonths)
  - [04. Boring Vector](#04-boring-vector)
    - [Unit tests](#unit-tests)
      - [xUnit: Fact & Theory](#xunit-fact--theory)
      - [Test naming styles](#test-naming-styles)
      - [Common mistakes](#common-mistakes)
    - [Comments style](#comments-style)
    - [Vector.ToString()](#vectortostring)
    - [Static vs static readonly vs const](#static-vs-static-readonly-vs-const)
    - [Mutable structs pitfalls](#mutable-structs-pitfalls)
      - [!!! Переделать !!!](#-переделать-)
    - [Immutable types, field and properties](#immutable-types-field-and-properties)
      - [What are fields and properties](#what-are-fields-and-properties)
      - [Auto-properties](#auto-properties)
      - [How to implement immutability](#how-to-implement-immutability)
  - [03. Drunk Fibonacci](#03-drunk-fibonacci)
    - [`IEnumerbale` Skip and Take problem](#ienumerbale-skip-and-take-problem)
    - [Type overflow](#type-overflow)
    - [How to iterate with `IEnumerator<int>`](#how-to-iterate-with-ienumeratorint)
    - [Buffer is shared between all chunks](#buffer-is-shared-between-all-chunks)
    - [Zeroing bits of 42](#zeroing-bits-of-42)
    - [Grouping](#grouping)
  - [05. Call Me Maybe](#05-call-me-maybe)
    - [Answers to the questions from the comments](#answers-to-the-questions-from-the-comments)
    - [Sidenote about `Type object pointers`](#sidenote-about-type-object-pointers)
    - [Construct new object in `Select`](#construct-new-object-in-select)
  - [06. Wubba Lubba Dub Dub](#06-wubba-lubba-dub-dub)
    - [Verbatim strings](#verbatim-strings)
    - [Split text to lines](#split-text-to-lines)
    - [Construct `string` from `IEnumerable<char>`](#construct-string-from-ienumerablechar)

<!-- /TOC -->

## 01. Primitive Types

### TryParse + throw standard exception

Рассмотрим такой вариант реализации одного из методов первого задания:

```cs
/// <summary>
/// Конвертирует строковое представление числа в его 32-битное знаковое целочисленное представление.
/// </summary>
/// <param name="s">Строковое представление числа.</param>
/// <returns>32-битное знаковое целочисленное представление числа.</returns>
internal static int Parse(string s)
{
    /*
        Продолжай идти простым путем -нужен метод, обратный методу ToString выше, который распарсит дефолтное строковое представление числа.
        Подсказка: у каждого примитивного типа есть набор статических методов, среди которых есть нужный.
    */
    int value;
    if (int.TryParse(s, out value)) {
        return value;
    } else {
        throw new ArgumentException("String does not contain correct integer", nameof(s));
    }
}
```

В текущем виде кто-то сделал двойную работу, по сути повторив то, что делает метод `int.Parse(string s)`. Вот если бы было известно, что делать в случае невозвожности корректно конвертировать строку в число, то да - было бы разумно воспользоваться `TryParse`.

Кстати, вот эти два варианта:

- Parse + try/catch + return defaultValue

```cs
try
{
    return int.Parse(s);
}
// обратите внимание - int.Parse может выбросить один из трех видов исключений
catch (ArgumentNullException) { }
catch (FormatException) { }
catch (OverflowException) { }

return defaultValue;
```

- TryParse + return defaultValue

```cs
return int.TryParse(s, out int result) ? result : defaultValue;
```

отличаются не только читабельностью, но и скоростью. Обработка исключений - штука затратная.

### Compare floats with default epsilon

Одна из самых распространенных ошибок этого задания - снабжать последний аргумент метода сравнения двух вещественных чисел значением по умолчанию:

```cs
/// <summary>
/// Возвращает результат сравнения двух вещественнозначных чисел.
/// </summary>
/// <returns>-1 - первое меньше второго, 0 - значения равны, 1 - первое больше второго.</returns>
internal static int Compare(double firstNumber, double secondNumber, double precision = 0.000001)
```

Причины дать аргументу значение по умолчанию:

- "Пользователь метода может не очень хорошо разбираться в предметной области, поэтому я дам аргументу значение, которое я, как эксперт в данной области, считаю хорошим в стандартном случае." Пример - коэффициенты настройки некоторого алгоритма или структуры данных. Почти всегда пользователю дается возможность вызвать метод с кастомными настройками, но при этом имеется некоторая настройка по умолчанию. При этом эта "ноубрейн" настройка будет хорошо работать для большинства.
- В подавляющем большинстве случаев метод будет вызываться именно с таким значением, т.е. логика по умолчанию подразумевает именно его. И наоборот - случай, когда пользотель захочет дать отличное от дефолтного значение, является исключительным.
- Параметр является опциональным. Тогда логично дать ему значение по умолчанию `null`.

В приведенном примере, чем значение 1e-6 лучше 1 тысячной или 1 миллиардной? Ведь абсолютно неизвестно заранее, какого порядка значения будут сравниваваться. Какое-бы значение ни было выбрано, оно не является "хорошим в большинстве случаев" и тем более ожидаемым. Не глядя, сможешь угадать, какая в чьей-то библиотеке выбрана точность для сравнения вещественных чисел?)

Представь, что пользователь твоего метода использует ее только для сравнения чисел порядка `1E+100`. Разница в порядке сравниваемых чисел и значения `precision` намного длиннее мантиссы, т.е. минимально возможная разница `firstNumber` и `secondNumber` больше `precision`. А это значит, что выражение `|firstNumber - secondNumber| <= precision` равнозначно `|firstNumber - secondNumber| <= 0`, т.е. по сути значения просто сравниваются на равенство `firstNumber == secondNumber`.

А представь теперь, что числа наоборот порядка `1E-20` - в таком случае данный метод будет возвращать, что все они равны ;)

Если пользователь разумный и задумался над подходящей для его задачи точностью, то он и так всегда будет передавать свое значение (какую-нибудь заведенную где-нибудь константу) - значение по умолчанию ему будет не нужно. Более того значение по умолчанию будет ему вредно -  если пользователь забудет где-то его передать, то компилятор не ругнется, и никто в "compile time" ошибки не заметит.

Если же пользователь не задумался об этой проблеме, то он конечно же воспользуется значением по умолчанию, чтобы не напрягаться, и будет ловить интересные ошибки из-за проблем, описанных выше.

## 02. Adventure Time!

### AreEqualBirthdays

Обсуждали в телеграме, зафиксирую здесь.

Я допускал две стратегии решения:

1. По аналогии с "тремя месяцами" сказать, что задача поставлена недостаточно ясно, поэтому требуется доработка, а пока - держи `NotImplementedException` или `NotSupportedException` (последний лучше подходит по семантике).
1. Попробовать додумать до наиболее частого случая - сравнения дат по паспорту.

С первой все понятно, для второй стратегии у меня лично логика такая. Разберем варианты `Kind`ов аргументов:

- `Utc` - имеет абсолютное время, но дату рождения в паспорт заносят "по местному", но мы не знаем по какому местному, поэтому имеется неразрешимая неопределенность.
- `Local` - имеет наше текущее локальное время, что вроде кажется подходящим, но на деле та же самая неопределенность, т.к. мы все еще не знаем локального времени для **той** таймзоны, где это значение было получено.
- `Unspecified` - дата "как есть", ровно так в паспорте записана дата рождение - без упоминания чего-либо, связанного с часовыми поясами, просто набор полей "год, месяц, день, час,...".

В таком случае `Kind == Unspecified` должен являться единственным имеющим смысл и разрешенным у аргументов данного метода. Можно еще дополнительно проверить, что у обоих аргументов TimeOfDay нулевой (т.е. добавить условие, что передается именно дата, а не время). На остальные кайнды логично кидать исключения.

### GetTotalMinutesInThreeMonths

__TL;DR__ Мораль задачи - относиться критически к заданиям. Вообще ко всему. В качестве решения хотелось увидеть отсутствие решения - `throw new NotImplementedException` - и соответствующие комментарии.

Петр Гежес как-то сказал (и я с ним не согласен):

> ... к счастью, в реальном мире таких задач __почти__ не бывает.

_Осторожно, цитата вырвана из контекста! ;)_

Возможно мне не везет, но в моей вселенной все с точностью наоборот. Иначе бы зачем, вообще, такая задача?

Примеры причин, по которым задачи формулируются некорректно или неоптимально:

- люди ошибаются,
- постановщик задачи может не знать того, что знаете вы,
- постановщик задачи вообще может не быть экспертом соответствующей области.

## 04. Boring Vector

### Unit tests

С одной стороны тестирование - очень обширная и сложная область с отдельной категорией специалистов. С другой - т.к. это смежная область, хорошо бы что-то про неё все же знать.

Написание тестов является довольно распространенной ахиллесовой пятой разработчиков. Как и любое новое занятие для человека, по началу оно оказывается медленным, скучным, малополезным и зачастую влекущим к еще большему геморрою. Если не развивать навык, ситуация сама по себе лучше не станет. В идеале же, конечно, умение писать хорошие тесты - очень крутой и полезный скилл. Как впрочем и многие другие, смежные с "непосредственно разработкой".

Далее под тестами будут подразумеваться именно юнит-тесты. Итак, ближе к делу - на что стоит обратить внимание.

#### xUnit: Fact & Theory

Чисто технически выглядит так, что разница лишь в том, есть ли входные параметры у тестового метода или нет. В принципе да, разработчики этого фреймворка могли бы оставить только `Theory` и поддерживать сигнатуры без входных параметров.

Тем не менее, существует разница в семантике:

- `Fact` - это инвариант, факт, который должен оставаться верным вне зависимости от входных данных. Пример: ты тестируешь что-нибудь вроде свойства идемпотентности метода (повторный вызов с теми же аргументами не меняет состояние системы и возвращает тот же результат). В таком случае абсолютно не принципиальны значения аргументов - важен лишь повторный вызов _с теми же аргументами_. Это инвариант системы и он не зависит от входных параметров.
- `Theory` - теория, которая верна для заданного множества входных значений.

Я в данном задании не обращаю внимание на правильное использование семантики. Для начала просто играемся с самим инструментарием.

#### Test naming styles

В отличие от названий обычных методов, названия тестовых методов обычно видят не в IDE, а в отчете работы системы прогона тестов. Например, у вас настроен автопрогон тестов после каждого билда, и отчет о проваленных тестах потом приходит по почте, в slack и т.п. В таком случае скорее всего под рукой исходников у вас не окажется, а значит на первый план выходит возможность быстро и однозначно из названия теста понять, что конкретно он тестирует.

Давай посмотрим, как можно было бы именовать тесты:

- `Test_<название тестируемого метода или функционала>`:

  - пример: `Test_SquareLength`
  - _не очевиден тестируемый сценарий_

- `Test_<название тестируемого метода или функционала>_<ожидаемый результат>`:

  - пример: `Test_Normalize_ReturnsZeroVector`
  - _не очевидно, почему и при каком сценарии возвращается ожидаемый результат_

- `Test_<название тестируемого метода или функционала>_<сценарий>_<ожидаемый результат>`:

  - пример: `Test_Normalize_ForZeroVector_ReturnsZeroVector`
  - _много служебных слов_

- небольшая оптимизация - убрать очевидный префикс, убрать лишние слова:

  - формат: `<тестируемый метод>_<сценарий>_<ожидаемый результат>`
  - примеры:

    - `Normalize_ZeroVector_Returns_ZeroVector`
    - `Normalize_NonZeroVector_Returns_VectorWithLengthEqualsOne`
    - `IntParse_NonDigitalString_Throws_FormatException`

- еще популярен стиль GivenWhenThen-style (GWT) - `Given_<начальное состояние>_When_<сценарий>_Then_<ожидаемый результат>`:

    - `Given_ZeroVector_When_CallNormalize_Then_GetZeroVector`
    - `Given_NonDigitalString_When_CallIntParse_Then_FormatExceptionIsThrown`
    - _возможно слишком "говорливый" стиль именования, больше подходит для "behavior tests", где желательно писать максимально естественным языком_

Основные советы:

- придерживайся единого стиля внутри команды
- найди золотую середину подробности названия.

#### Common mistakes

Просто общие моменты:

- _Тестируй следование контракту, не правильность текущей реализации (т.е. будто не знаешь реализацию)._

  Не знаю, сталкаивались ли вы с этим, но я несколько раз на собеседованиях после реализации требуемого кусочка кода буквально через секунду после просьбы "а давайте теперь напишем к вашему методу тесты" находил ошибку в своем коде - достаточно было поменять в голове роль и мыслить в ключе "как сломать этот метод". Отсюда следующий пункт.

- _Твоя задача сломать тестируемый кусок, а не подтвердить, что он якобы без багов._

  В домашках во входных данных я не увидел ни одной стандартной константы `double` ;) В том виде, в котором вы их сдавали, тесты выглядели больше как попытка убедить себя в правильности вашей реализации.

- _Лучше 0 тестов, чем много плохих._

  Любые тесты нужно писать, а потом поддерживать. И это довольно трудоемкое (и зачастую скучное) занятие.

- _Много вариаций похожих входных данных не имеет смысла._

  Каждый набор входных данных должен покрывать какое-то семейство входных данных.

- _Один тест - проверка одного контракта._

  Проще писать, проще читать, проще менять, проще локализовать проблему.

- _Правильно работающая система должна проходить тесты._

  Ира, вот так делать неправильно:

  `[InlineData(0, 0, 5, 5, 5)] // not working -- its correct`

  Иначе, как после прогона тестов автоматически понять, что реализация удовлетворяет заданным контрактам.

- _Сравнивай с ожидаемым значением результата, а не якобы правильным вычислением результата._

  В вычислении проще ошибиться. Здесь, например, можно не заметить переполнение:

  `Assert.Equal(v.IntegerSquareLength(), x * x + y * y);`.

- `Assert.Equal` имеет перегрузку `void (double x, double y, int precision)` - для сравнения вещественных чисел лучше пользоваться ей.

### Comments style

Если ты посмотришь комментарии в стандартной библиотеке, то увидишь, что у типов, интерфейсов, перечислений, свойств и методов (т.е. по-моему у всего комментируемого) комментарий как бы отвечает на вопрос "что оно делает?" и тем самым начинается с глагола:

- свойство `DateTime.Now` (обрати внимание, из комментария понятно, что оно read-only):
  > Gets a System.DateTime object that is set to the current date and time on this computer, expressed as the local time.

- а вот изменяемое свойство `this[int index]` интерфейса `IList<T>`:
  > Gets or sets the element at the specified index.

- публичное поле `DBNull.Value`:
  > Represents the sole instance of the System.DBNull class.

- класс `Array`:
  > Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.

- класс атрибута `SerializableAttribute`:
  > Indicates that a class can be serialized. This class cannot be inherited.

- интерфейс `IDisposable`:
  > Provides a mechanism for releasing unmanaged resources.

- перечисление `GCCollectionMode`:
  > Specifies the behavior for a forced garbage collection.

Единственное исключение из правил, которое я знаю, это классы исключений. Базовые типы исключений, которых самих по себе никогда не выбрасывают, похоже, имеют комментарии в соответствии со стилем выше, а вот классы "выбрасываемых" исключений почти всегда имеют вид `The exception that is thrown when ...`. Сравни:

- `Exception` (это самый базовый класс исключений):
  > Represents errors that occur during application execution.

- `StackOverflowException` (исключение, которое названо в честь того-самого-сайта - его обычно выбрасывает мозг программиста после того, как не может найти на том-самом-сайте решение своей проблемы, и приходится читать кучу сложных статей, блогов и документации) :
  > The exception that is thrown when the execution stack overflows because it contains too many nested method calls. This class cannot be inherited.

Если ты посмотришь мои комментарии в первых лабах, то заметишь, что я стараюсь следовать этим гайдлайнам. Кроме типов :( Я, честно говоря, сам до текущего момента не обращал внимание, что и к ним комменты начинаются с глагола, и писал всегда ответ на вопрос "что это?", начиная с существительного.

Тебе я тоже предлагаю следовать приведенному стилю. Ну или следовать другим гайдлайнам, которые тебе больше по душе. Главное, чтобы стиль был достаточно консистентным на протяжении всего твоего кода, а сами комментарии были хорошими: понятными, короткими и ёмкими.

ниже не готово
___
Примеры:

- Вектор, на который необходимо домножить
- Домножаем на число
- Вектор, который нужно добавить к this
- Вернуть произведение.

Про `GetAngleBetween` - Acos
Комментарии к значениям перечисления.

ниже пункты не закончены
___

### Vector.ToString()

Все примеры ниже дают один и тот же результат. Сравни их и подумай, какой когда удобнее.

```cs
// ака interpolated string (предваряются знаком доллара).
return $"({x}; {y})";
```

```cs
// строка формата тоже короткая, но легко запутаться в индексах аргументов
return string.Format("({0}; {1})", x, y);
```

```cs
return "(" + x + "; " + y + ")";
```

или то же самое, но длиннее

```cs
return "(" + x.ToString() + "; " + y.ToString() + ")";
```

и самый дерзкий вариант

```cs
return new StringBuilder("(").Append(x).Append("; ").Append(y).Append(")").ToString();
```

### Static vs static readonly vs const

Преамбула: разговор про то, как задать числовую константу `Epsilon` для обозначения точности сравнения вещественных чисел.

Проблема: не все явно указывали её константность.

Данная переменная изменяема, а по смыслу она константа. Для значимых типов так и пишут

`private const double Epsilon = 1e-6;`.

Ссылочные типы константами не сделаешь кроме:

- типа `string`:
    ```cs
    const string s = "abc";
    ```
- инициализации null'ом, т.е. для любого ссылочного типа константа может быть только пустая:
    ```cs
    const SomeReferenceType someInstance = null;
    ```

Поэтому для ссылочных типов самый близкий аналог констант это `static readonly`.

### Mutable structs pitfalls

#### !!! Переделать !!!

Представь себе такой код:

```cs
var vectors = new[] {
    new Vector(10, 20),
    new Vector(-5, 5)
};

var shift = new Vector(42, 300);
foreach (var v in vectors)
{
    Console.WriteLine(v);   // v
    var u = v.Add(shift);
    Console.WriteLine(v);   // v + shift
    Console.WriteLine(u);   // v + shift
    Console.WriteLine();
}
Console.WriteLine("=====");

foreach (var v in vectors)
{
    Console.WriteLine(v);   // v!!!
}
Console.WriteLine("=====");

for (int i = 0; i < vectors.Length; i++)
{
    Console.WriteLine(vectors[i]);  // old vectors[i]

    Console.WriteLine(vectors[i].Add(shift));   // vectors[i] + shift
    Console.WriteLine(vectors[i]);  // vectors[i] + shift

    var v = vectors[i];
    Console.WriteLine(v.Add(shift));    // vectors[i] + 2 * shift
    Console.WriteLine(vectors[i]);      // vectors[i] + shift
    Console.WriteLine();
}
```

Это один из примеров случая, когда изменяемость значимых типов влечет к не очень ожидаемому поведению.  И таких примеров на самом деле достаточно много. Отсюда пошло "mutable structs are evil". Это как голые указатели в плюсах. Иногда просто вынужден их использовать, но в большинстве случаев выгоднее обойтись чем-то попроще. В данном случае это неизменяемые структуры.

А вот второй пример:

```cs
var v = new Vector(1, 1);   // v = (1; 1)
var u = v.Scale(-1);        // u = v = (-1; -1)
var w = u.Scale(-5);        // u = w = (5, 5) != v = (-1, -1)

Console.WriteLine(v);       // (-1; -1) !!!
Console.WriteLine(u);       // (5, 5)
Console.WriteLine(w);       // (5, 5)
```

Надеюсь, я тебя немного убедил? Перепиши структуру так, чтобы она была неизменяемой, и каждая операция возвращала новый объект.

Изменяемые структуры имеют право на жизнь, иначе бы их на уровне языка уже давно запретили, но за это приходится расплачиваться заметно более высокими требованиями к концентрации внимания, покрытию кода тестами и пр.

### Immutable types, field and properties

Усаживайся поудобнее, впереди длинная история.

#### What are fields and properties

Единственные реальные данные, которые содержат объекты классов или структур, это поля:

```cs
class Foo
{
    // это поле можно менять только внутри класса, снаружи к нему доступа нет
    private int _x;

    // это поле публично - к нему могут обращаться и менять все
    public int _x;
}
```

Поле можно сделать публичным как в примере. А еще поле можно сделать `readonly` - сказать явно, что данное поле нельзя менять после инициализации в конструкторе. Так что да, `public readonly` поле является возможным решением в нашем случае. Но не самым "идеологически верным".

Поля структур и классов являются деталью их реализации (состояния), которую по правилам ООП принято скрывать от пользователя. Для инкапсуляции полей в c# есть свойства:

```cs
class Foo
{
    private int _x;

    // это публичное свойство с публичными геттером и сеттером, а поле _x в этой ситуации
    // называют  backing field
    public int X
    {
        get { return _x; }
        set { _x = value; }
    }

    // но свойство может быть и таким
    public int StrangeX
    {
        get
        {
            Console.WriteLine("hello");
            return -1;
        }
        set
        {
            // ничего не делать
        }
    }

    // потому что по факту свойство - это лишь пара методов, на которые его заменит компилятор. Для последнего примера выше будет что-то такое:

    public int get_StrangeX()
    {
        Console.WriteLine("hello");
        return -1;
    }
    public void set_StrangeX(int value)
    {
        // ничего не делать
    }

    // и все обращения к свойству будут заменены на вызовы соответствующих методов
    // в реальности названия методов будут другими - главное, что они не известны тебе и не пересекаются с имеющимися.
}
```

Как видишь, если мы хотим следовать принципам ООП, то инкапсуляция полей в свойства требует довольно много писанины (пусть и автоматизируемой многими IDE):

```cs
// вместо того, чтобы написать просто
public int X;

// приходится писать так!
private int _x;
public int X
{
    get { return _x; }
    set { _x = value; }
}

```

#### Auto-properties

Дабы уменьшить страдания программистов через некоторое время в C# ввели так называемые авто-свойства (auto-properties), имеющих следующий синтаксис:

```cs
public int X { get; set; }


//Данное свойство компилятор сам развернет в:

private int _x; // название поля будет какое-то уникальное и тебе неизвестное.
public int get_X() { return _x; }
public void set_X(int value) { x = value; }
```

Как видишь, писать значительно меньше. Обычно свойства именно авто-свойства, т.е. не содержат никакой логики, кроме "вернуть значение поля" и "задать новое значение полю".

Свойства, как и поля, могут иметь все четыре модификатора видимости: `public`, `internal`, `protected`, `private`. Но они не могут быть `readonly`. Потому что это не данные, а пара методов. Более того, что у обычных свойств, что у авто-свойств, геттеру и сеттеру можно давать разную видимость:

```cs
public int X
{
    get;  // публичный, т.к. свойство публично
    private set;  // а вот сеттер приватный
}
```

#### How to implement immutability

Давай теперь посмотрим, какие есть варианты задать координату X структуры (или класса) публичной и неизменяемой:

- public readonly field. Минусы - не по ООПшному:

```cs
public readonly int X;
```

- публичное авто-свойство с приватным сеттером. Минусы - не по-настоящему неизменяемый, т.к. внутри менять можем:

```cs
public int X { get; private set; }
```

- публичное обычное свойство с readonly backing field. Минусы - господи, сколько писать, господи, какой нелаконичный и непонятный код:

```cs
private readonly int _x;

// не авто-свойство
public int X
{
    get { return _x; }
    // сеттер у обычных свойств можно не писать
}
```

В итоге до C# 6.0 самый идеологический правильный способ сделать по-настоящему иммутабельную структуру был ооочень некрасивым и неудобным. Поэтому большинство либо забивало на ООП и выбирала первый способ, либо на "не-настоящность" неизменяемости, выбирая второй.

Ровно для устранения проблемы третьего варианта в шестых шарпах добавили get-only auto-properties:

```cs
// полный аналог третьего варианта
public int X { get; }
```

Это правильный способ задавать иммутабельные свойства, а с помощью них - иммутабельные типы.

## 03. Drunk Fibonacci

### `IEnumerbale` Skip and Take problem

Skip и Take - это не перемотка времени :)

```cs
var seq = Enumerable.Range(1, 10).Select(x => { Console.WriteLine(x); return x; });

var skip2 = seq.Skip(2);
var take2 = skip2.Take(2);
var take3 = skip2.Take(3);
```

В данном случае `skip2` - это не запоминание состояния генератора последовательности. Все это разворачивается в:

```cs
var seq = Enumerable.Range(1, 10).Select(x => { Console.WriteLine(x); return x; }).Skip(2);

var skip2 = Enumerable.Range(1, 10).Select(x => { Console.WriteLine(x); return x; }).Skip(2);
var take2 = Enumerable.Range(1, 10).Select(x => { Console.WriteLine(x); return x; }).Skip(2).Take(2);
var take3 = Enumerable.Range(1, 10).Select(x => { Console.WriteLine(x); return x; }).Skip(2).Take(3);
```

Тем не менее ни одна из последовательностей не материализована - каждая из переменных как бы хранит "конструктор последовательности". Но если мы их проматериализуем:

```cs
var materializedSeq = seq.ToList(); // или с помощью любого другого материализующего метода типа First, FirstOrDefault, Last, Sum, Count и т.п.

var materializedSkip2 = skip2.ToList();
var materializedTake2 = take2.ToList();
var materializedTake3 = take3.ToList();
```

, то увидим, что каждая последовательность сгенерирована и проитерирована ___с самого начала___. Решарпер обычно в таких случаях показывает ворнинг "possible multiple enumeration of ienumerable" - мол, ты перечисление несколько раз итерируешь с самого начала.

В данном примере это не страшно, т.к. это перечисление можно спокойно заново сгенерировать и материализовать.

Другое дело, когда перечисление берется из БД. Например, если есть некоторый метод, который возвращает `IEnumerable<Account>` - список аккаунтов. В таком случае нужно понимать, что каждый раз, когда мы "заново" материализуем это перечисление, будет произведен запрос к БД!

А в некоторых случаях перечисление может генерироваться, прослушивая, например, сокет - и в таком случае оно вообще не воспроизводимо. Нельзя отмотать время назад и заново получить те данные, которые мы уже только что получили.

Поэтому обычно, если нужно проитерировать одно и то же перечисление больше одного раза, наиболее безопасным и правильным вариантом является материализация последовательности в массив с последующими итерированиями по нему. Либо менять интерфейс и требовать на вход не `IEnumerable<>`, а что-то уже материализованное, например, `IReadOnlyList<>`, `IReadOnlyCollection<>`, `IList<>` и т.п.

### Type overflow

> При вычислении сложения переполнение типа разрешено и всячески поощряется.

Не все выражали данную просьбу явно в коде. Вспомни первую лабу.

### How to iterate with `IEnumerator<int>`

В данном коде

```cs
IEnumerator<int> number = GetDrunkFibonacci().GetEnumerator();
while (true)
{
    int[] chunk = new int[16];
    for (int i = 0; i < chunk.Length; ++i)
    {
        number.MoveNext();
        chunk[i] = number.Current;
    }
    yield return chunk;
}
```

правильнее заменить явное итерирование по последовательности циклом `foreach`:

```cs
const int chunkSize = 16;
var i = 0;
int[] chunk = new int[chunkSize];

foreach (var x in GetDrunkFibonacci())
{
    chunk[i] = x;
    i++;

    if (i == chunkSize)
    {
        yield return chunk;

        i = 0;
        chunk = new int[chunkSize];
    }
}
```

### Buffer is shared between all chunks

Довольно частая ошибка - пользоваться одним и тем же буффером под чанки:

```cs
var chunk = new int[16];
int counter = 0;
foreach (int el in GetDrunkFibonacci())
{
    chunk[counter] = el;
    counter += 1;
    if (counter == 16)
    {
        counter = 0;
        yield return chunk;
        // вернули chunk, но продолжаем работать с ним же - на следующей итерации перезатрем его первый элемент!
    }
}
```

В данном случае используется один единственный объект буффера - мы возвращаем на него ссылку и следом начинаем его же перезатирать.

### Zeroing bits of 42

> У получившегося числа с некоторой вероятностью зануляет биты, соответствующие числу 42 (т.е. те биты, которые в бинарном представлении числа 42 равны единице).

Ошибкой было использовать `XOR`: `x = x ^ 42;`

Вспомни таблицу истинности `XOR` и подумай, почему это ошибка.

Правильный ответ: `x = x & ~42;`

### Grouping

Часть решений имело лишние усложнения вроде такого:

```cs
GetDrunkFibonacci()
    .Take(10000)
    .GroupBy((i => Math.Abs(i % 8)), (i => i), ((i, grouped_by_deduct) => (field_key: i, field_arr: grouped_by_deduct)))
    .ToDictionary((tuple => tuple.field_key), (tuple => tuple.field_arr.Distinct().Count()));
```

То же самое можно переписать проще:

```cs
GetDrunkFibonacci()
    .Take(10000)
    .GroupBy(i => Math.Abs(i % 8))  // каждая группа IGrouping<int> это объект IEnumerable<int> + свойство Key, по которому группируют
    .ToDictionary(g => g.Key, g => g.Distinct().Count());
```

## 05. Call Me Maybe

### Answers to the questions from the comments

1. Почему Maybe - структура?

    - не может быть `null`, что резко снижает количество лишних проверок

1. Зачем может быть нужно такое выделенное значение? Сколько по факту будет экземпляров данного объекта?

    ```cs
    public static readonly Maybe<T> Nothing = new Maybe<T>();
    ```

    - семантически пустая Maybe явно выделяется, поэтому логично задать соответствующее значение явно. В конкретном случае Maybe как структуры, это исключительно только вопрос семантики:

    ```cs
    //что понятнее?

    return new Maybe<MyClass>();
    //или
    return Maybe<MyClass>.Nothing;
    ```

    - самих экземпляров переменной `Maybe<T>.Nothing` будет по одному на каждый используемый тип `T`, т.к. `Maybe<int>` и `Maybe<MyFooClass>` - два разных типа. См. [соответствующее обсуждение на SO](https://stackoverflow.com/questions/3037203/are-static-members-of-a-generic-class-tied-to-the-specific-instance).

    - а еще это значение стоило бы задать не полем, а `readonly`-свойством:

    ```cs
    public static Maybe<T> Nothing { get; } = new Maybe<T>();   // кстати, если что, .net гарантирует thread-safety инициализации статических полей/свойств.
    ```

1. Почему конструктор, принимающий значение, скрыт?

    ```cs
    private Maybe(T value)
    {
        _value = value;
        HasValue = true;
    }
    ```

    - ремарка: конструктор без параметров у структур неявно существует всегда и открыт. Закрыть его невозможно.
    - чтобы значение `value` точно было не-`null`, я скрыл конструктор и сделал фабрику объектов Maybe в операторе неявного приведения. Явное приведение методами `.ToMaybe()` само экземпляры не создает, а пользуется фабрикой.

1. Про какой подводный камень нужно помнить, когда объекты `Maybe<T>` используются как объекты типа `IEnumerable<T>`?

    - Всякий раз, когда объекты значимого типа используются как объекты интерфейса, они упаковываются:

```cs
interface IFoo
{
    void Foo();
}

struct MyFoo : IFoo
{
    void Foo() => Console.WriteLine("Foooooo!");
    void Bar() => Console.WriteLine("Baaarrr!");
}

// ..

// с переменной x все хорошо - никаких упаковок
MyFoo x = new MyFoo();
x.Foo();
x.Bar();


IFoo y = new MyFoo();   // вот здесь произойдет упаковка.
y.Foo();
```

Здесь в примере мы теряем информацию о реальном типе объекта, статический тип `y` - `IFoo`. Но рантайму все же нужно знать реальный тип - где брать реализацию интерфейсного метода.
___

### Sidenote about `Type object pointers`

Вспомни, что каждый объект ссылочного типа помимо своих данных хранит также указатель на объект-тип. То есть объект типа `List<int>` хранит указатель на объект типа `Type`, хранящий информацию о типе `List<int>`.

В Рихтере про это есть. Вот возможно немного замусоренная картинка оттуда:

![type object pointer](pics/type_object_pointer.png)

На этой картинке приведен небольшой кусочек кода и состояние памяти на момент последней строки кода. Не разбирайте код, просто обратите внимание, что в приведенном примере в куче есть два объекта, имеющих тип `Manager`.

Оба объекта содержат ссылку на один и тот же объект-тип `Manager`. А он - самый обычный объект, который имеет тип `Type`, а, значит, тоже содержит ссылку на свой объект-тип `Type`. Ну а тот, в свою очередь, тоже обычный объект. И тоже типа `Type`. Поэтому его ссылка на объект-тип указывает на самого себя.

Объекты-типы содержат таблицу экземплярных и статических методов, а также статические поля.

Конец ремарки
___

Вот этот объект-тип нужен именно для доступа к нужной таблице методов и вообще ко всей иерархии наследования. В данной ситуации он нужен объекту значимого типа, поэтому его упаковывают, делая объектом ссылочного типа - упакованный объект будет содержать ___копию___ оригинального значения и указатель на объект своего реального типа `MyFoo` [и еще индекс синхронизации, но разговор не о нем].

Теперь вернемся к объектам `Maybe<T>`, которые используются как объекты интерфейса `IEnumerable<T>`. Любой метод-расширение из LINQ, который принимает на вход `IEnumerable<T>`, и которому мы передадим объект `Maybe<T>`, вызовет упаковку этого объекта:

```cs
// предполагается, что Maybe<T>: IEnumerable<T>
// и метод Where не определен в самой Maybe<T>

Maybe<T> x = 10.ToMaybe();

// компилятор возьмет метод-расширение Enumerable.Where из LINQ
var filtered = x.Where(t => t < 20);

// можем то же самое написать, используя static invocation:
var filtered2 = Enumerable.Where(x, t => t < 20);

// сигнатура метода Where следующая:
IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate);

// таким образом всякий раз, когда аргументом параметра source передается
// объект Maybe<T>, произойдет упаковка!
```

### Construct new object in `Select`

Такой код ведет к ошибке:

```cs
public Maybe<TResult> Select<TResult>(Func<T, TResult> map)
{
    return HasValue ? new Maybe<TResult>(map(_value)) : Maybe<TResult>.Nothing;
}
```

, если вызвать его так:

```cs
var res = 10
    .ToMaybe()
    .Select(_ => (object) null);

Console.WriteLine($"HasValue: {res.HasValue}");       // true
Console.WriteLine($"_value: {res.Value == null}");    // true
```

Конструктор должен использоваться только в операторе неявного приведения - он является настоящим "конструктором" объектов.

Можно было бы продублировать логику в конструкторе, что не очень хорошо. С другой стороны можно было бы поставить явную проверку в конструкторе на `value != null`, что уже заметно лучше.

## 06. Wubba Lubba Dub Dub

### Verbatim strings

В c# есть так называемые `verbatim string`, которые начинаются с @ и позволяют не писать backslash дважды:

```cs
var sadPath = "c:\\petr\\ustal\\ot\\vashikh\\slashey";
var happyPath = @"c:\petr\feels\lyoubovno\i\prelstivo";
```

### Split text to lines

В задании про разбиение текста на строки не все решили заморачиваться с тем, что на разных платформах принят разный формат перевода строки (см [wiki](https://en.wikipedia.org/wiki/Newline)). В целом, этого и не требовалось, но вот вариант, который учитывает все случаи:

```cs
input.Split(new[] {"\r\n", "\r", "\n"}, StringSplitOptions.None);
```

В таком случае мы не потеряем пустых строк в оригинальном тексте и правильно учтем все возможные варианты перевода строки. Обрати внимание, что `"\r\n"` идет на первом месте - это важно.

В случае, когда необходимо разбить на строки текст очень большой длины `Split` может оказаться не очень удачным выбором (например, доп затраты по памяти). Тогда можно воспользоваться таким вариантом:

```cs
public static IEnumerable<string> SplitToLines(this string input)
{
    if (input == null)
    {
        yield break;
    }

    using (var reader = new System.IO.StringReader(input))
    {
        while (!reader.EndOfStream)
        {
            yield return reader.ReadLine();
        }
    }
}
```

### Construct `string` from `IEnumerable<char>`

Существует довольно много способов это сделать. Естественно, все они имеют свои плюсы и минусы, но наиболее предпочтимыми являются следующие:

```cs
// by string constructor
return new string(charSequence.ToArray());

// by string builder
var sb = new StringBuilder();
foreach (var c in charSequence)
{
    sb.Append(c);
}
return sb.ToString();
```

В большинстве случаев первый вариант окажется и достаточно коротким/читабельным, и достаточно быстрым. Более того, если `charSequence` имеет реальный тип `char[]`, то он будет максимально быстрым, т.к. в конструкторе строки есть соответствующая проверка и оптимизация на этот случай. В некоторых же случаях может оказаться более предпочтительным вариант со `StringBuilder`.

Тем не менее, я видел следующий варианты:

```cs
// by join
return string.Join(string.Empty, charSequence));

// or the same by concat
return string.Concat(charSequence);
```

Оба этих варианта могут быть довольно сильно медленнее, что зачастую не принципиально.