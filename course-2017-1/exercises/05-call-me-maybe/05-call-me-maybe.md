# 05. Call Me Maybe

## Entry Point

Рядом с этим документом расположена папка с солюшеном `CallMeMaybe`, открывай его. Пока он открывается, читай дальше :)

## Монада _maybe_

Давай рассмотрим следующую конструкцию - некий обобщенный строго-типизированный контейнер, который либо содержит значение, либо не содержит ничего. В мире функциональных языков такая конструкция известна как монада _maybe_. Не будем вдаваться, почему она является монадой - не удивлюсь, если про это таинственное слово ты знаешь больше чем я. Просто попробуем в качестве тренировки реализовать такую конструкцию и посмотреть, чем она может быть удобна (ну или наоборот).

В простейшем варианте она могла бы выглядеть как-то так:

```cs
struct Maybe<T>
{
  private T _value;

  public bool HasValue {get; private set;}
  public T Value
  {
    get { return HasValue ? Value : throw new InvalidOperationException()};
  }
}
```

Для ссылочных типов такая конструкция на первый взгляд не особо нужна - есть выделенное значение `null`, которое позволяет определить, переменная на что-то указывает или нет. У значимых же типов такого выделенного значения нет, что, кстати, и послужило причиной добавления в .Net структуры `Nullable<T>`, которую ты уже знаешь. Наверняка ты заметил[-а], что структура `Nullable<T>` один в один повторяет приведенную выше структуру `Maybe<T>` - ее внутреннее представление действительно так же состоит из двух полей/свойств: булева флага `HasValue` и значения `Value`.

Итак, получается, что для ссылочных типов аналога `Maybe` нет, потому что кажется ненужным, а для значимых есть - `Nullable<T>`. Тем не менее иногда хотелось бы:

- иметь один контейнер и для ссылочных, и для значимых типов, который либо `не имеет значения`, либо `имеет not-null значение`.
- расширять функционал только одного этого контейнера каким-то необходимым функционалом.

### Пример такого функционала

Лично я знаю и сталкивался лишь с одним примером. Представь, что есть граф вычислений (узлы-состояния и ребра-вычисления), где каждое вычисление может окончиться неудачей, и твоя логика на каждом шаге - "если предыдущий шаг был успешен, то выполни следующий". При чем, как видишь, неудачу в данном случае хочется завершать "тихо" - не исключением. Например, потому что исключения это дорого или в каком-то случае неудобно. Т.е. имеем какую-то такую логику:

```cs
SomeObject Foo(InObj input)
{
  var step1Res = Step1(input);
  if (step1Res != null)
  {
    var step2Res = Step2(step1Res);
    if (step2Res != null)
    {
      // step3 и т.д.
    }
    else {
      // в случае неудачи возможно есть какая-то запасная логика и т.п.
    }
  }
  return null;
  // Или SomeObject может быть типом-оберткой над значением, т.е. содержать либо значением в случае успеха, либо объект ошибки в случае неудачи,
  // тогда будем возвращать не null, а какой-то объект ошибки.
}
```

В такой ситуации код обрастает множеством проверок на `null` - это может замыливать логику, превращать код в ёлочку со множеством вложенных блоков и т.д. С появлением `null propagation` (оператор `?.`) жизнь стала чуть лучше, но тем не менее и он далеко не всегда спасает.

Неважно, убедил ли я тебя или нет в существовании подобной проблемы, давай просто представим, что мы находимся в параллельной вселенной, где такая проблема есть и очень раздражает местных программистов :) В целом, примеры кода в данном задании достаточно искусственные.

## CallMeMaybe.BaseModel

Итак, alt-tab'айся в открытый солюшен. В нем довольно много проектов (Петр постарался). Начнем с проекта `CallMeMaybe.BaseModel` - это библиотека вспомогательных классов, которые понадобятся нам в этой лабе. Здесь есть следующие файлы:

- `IOneRecipeChef.cs` - интерфейс воображаемого повара, который умеет готовить только тыквенные маффины. Тыквенные маффины - звучит аппетитно, не правда ли? Если чувствуешь голод, то лучше утолить его сейчас - в этой лабе будут упоминания еды))
- `CookingStuff.cs` - файл с кучей мелких вспомогательных типов, олицетворяющих ингредиенты и кухонную утварь. Особо не вникай в него, просто пробегись взглядом. Обрати только внимание на класс `CookingTable` - это своеобразный репозиторий ингредиентов, представь, что доступ к ним возможен только с помощью него. Заметь - все методы `CookingTable` возвращают `Nullable<T>` типы. Представь, что пространство-время на кухне крайне нестабильно, поэтому успех каждого действия не гарантирован - отсюда возможные `null`-ы.
- `NaiveChef.cs` - содержит "наивную" реализацию интерфейса "повар одного рецепта". Сам повар не только наивен, но и эмоционально нестабилен (учитывая в какой кухне он находится), поэтому его действия тоже не всегда гарантированно успешны. А еще он попросту иногда ошибается. Люди ошибаются, понимаешь?

Посмотри подробнее на реализацию "наивного шефа", а точнее на реализацию алгоритма приготовления маффинов. Как видишь, описанная ранее проблема этой параллельной вселенной здесь несколько гиперболизирована. Это хорошо. Возможно у нас получится сделать код чуть чище и читабельнее.

## CallMeMaybe.V1

Теперь ныряй в проект `CallMeMaybe.V1`. Для начала посмотри на частичную реализацию `MaybeChef` - я частично переписал алгоритм приготовления, используя структуру `Maybe<T>`. Не пугайся, что компилятор показывает кучу ошибок - с ними мы разберемся чуть позже.

Пока же обрати внимание, что никаких явных сравнений с `null` уже не делается - все проблемные куски уложились в цепочку последовательных вызовов метода `Select`. Думаю, ты уже догадался[-ась], что этот метод исполняет переданную ему лямбду только в том случае, когда монада содержит значение, т.е. все проверки на `null` попросту скрыты в этом методе.

С одной стороны логика выражена чуть лаконичнее, с другой - теперь мы имеем запутанные цепочки вызовов метода `Select` и др. Тем не менее давай для начала попробуем реализовать поддержку такого варианта.

### V1.Maybe

Переходи к структуре `Maybe` в этом же проекте - там уже есть некоторая заготовка, которую тебе нужно доделать. Двигайся сверху вниз, отвечай на вопросы, добавляй реализации методов и параллельно читай этот раздел дальше.

Базовый функционал будет состоять из оператора неявного приведения к `Maybe<T>`, что позволит, например, писать так:

```cs
Maybe<int> x = 10;

// или

Maybe<T> ToMaybe<T>(T value)
{
  return value;
}
```

Реализация оператора неявного приведения должна учитывать, есть ли у переданного объекта значение или он равен `null`, и, соответственно:

- либо оборачивать значение в `Maybe<T>`
- либо выдавать `Maybe<T>.Nothing`.

Напиши реализацию оставшихся методов. Т.к. я не сопроводил код комментариями, поясню логику для метода `Select`. Монада `Maybe<T>` похожа на коробочку либо пустую, либо с содержимым заданного типа. Так вот `Select`:

- для пустой коробочки типа `Maybe<T>` - превращает её в пустую коробочку типа `Maybe<TResult>`
- для непустой коробочки типа `Maybe<T>` - превращает её содержимое типа `T` в нечто типа `TResult` с помощью переданной функции-модификатора и потом кладет результат в коробочку типа `Maybe<TResult>`.

Это логика для перегрузки метода `Select`, которая принимает функцию-модификатор с сигнатурой `map: T -> TResult`. Другая перегрузка принимает функцию-модификатор с сигнатурой `T -> Maybe<TResult>` - там результат применения функции-модификатора уже помещен в коробочку, как видишь. Остальные методы работают по аналогии. Например, `XxxElse`, соответственно, обрабатывают случаи пустой монады.

### MaybeExtensions

Ещё базовый функционал будет состоять из класса `MaybeExtensions`, содержащего методы расширения `ToMaybe<T>`, позволяющие объекты любого типа обернуть в `Maybe<T>`. Как думаешь, сколько таких методов нам понадобится?

Один очевиден: `ToMaybe<T>: T --> Maybe<T>`.

Но со значимыми типами это не всегда будет удобно, если они уже обернуты в `Nullable` - вариант `ToMaybe<T?>: T? --> Maybe<T?>` не очень подходит. Зачем нам значение значимого типа, по сути дважды обернутый в монаду maybe - хотелось бы иметь отдельный метод `ToMaybe<T?>: T? --> Maybe<T>`.

Итак, нужна реализация двух методов-расширений `ToMaybe<T>`.

### MaybeChef

Возвращайся к `MaybeChef` - если ты все сделал[-а] правильно, теперь ошибок компиляции быть не должно. Добавь реализацию оставшемуся методу данного класса. Теперь можно провеять работу. Данный проект для удобства является проектом консольного приложения, поэтому с ним можно немного поиграться - чекни `Program.cs`, там я уже есть некоторая заготовка.

Как наиграешься, переходи к следующему шагу.

## CallMeMaybe.V2

В проекте `CallMeMaybe.V2` реализация `MaybeChef` выглядит немного иначе - код переписан с использованием синтаксиса LINQ-запросов. В этой части задания мы будем разбираться, за счет чего появилась такая возможность, которой в первой версии не было (на самом деле я чуть-чуть лукавлю, но об этом позже).

### IEnumerable\<T>

Первый мне пришедший в голову способ - воспользоваться возможностями `IEnumerable<T>`. Мы касались этого вопроса в `Drunk Fibonacci`, поэтому давай рассуждать так: "я не уверен, как устроен синтаксис LINQ-запросов под капотом, но знаю, что данный интерфейс имеет его поддержку". Let's do this!

Открывай `Maybe` и скопируй в него реализации тех методов, которые уже были реализованы в предыдущей части. Ненужные я удалил.

Без реализации остались только методы интерфейса `IEnumerable<T>`.

Точнее всего один. Второй я реализовал за тебя - это `non-generic` метод `non-generic` интерфейса `IEnumerable`, который нам достался в наследство от первых версий .Net Framework. `Generic` же версия интерфейса (=`IEnumerable<T>`) наследует `non-generic` версию (=`IEnumerable`) из соображений совместимости - чтобы дженерик версии интерфейсов удовлетворяли и недженерик версиям (т.е. все новые фишечки работали и в старых механизмах тоже).

В общем особо не заморачивайся по этому поводу - как видишь, в `non-generic` методе я просто вызываю `generic` версию метода. Однако обрати внимание на сигнатуру этого метода:

```cs
IEnumerator IEnumerable.GetEnumerator()
```

Это так называемая явная реализация интерфейса. Можешь прочитать про неё на [SO](https://stackoverflow.com/a/4103445/1094048) (см. первые два ответа).

Итак, тебе лишь осталось реализовать следующий метод `GetEnumerator`:

```cs
public IEnumerator<T> GetEnumerator()
```

По смыслу мы хотим наш объект `Maybe<T>` рассматривать как последовательность. Какая она может быть? А вот такая:

- `HasValue == false`: пустая
- `HasValue == true`: из одного элемента `_value`

Пусть тебя не смущает возвращаемый тип `IEnumerator<T>`. Представь, что возвращаемый тип `IEnumerable<T>` (они конвертируемы друг в друга). Метод же, возвращающий `IEnumerbale<T>`, ты уже делал[-а] в 4ой лабе, генерируя `DrunkFibonacci`.

Если получилось, теперь мы можем писать так:

```cs
var result =
  from x in SomeX().ToMaybe() // код ниже будет выполнен только в случае, если SomeX().ToMaybe() != Maybe<T>.Nothing
  let xx = x * x
  from y in SomeY().ToMaybe() // код ниже будет выполнен только в случае, если и SomeY().ToMaybe() != Maybe<T>.Nothing
  let yy = y * y
  let len = xx + yy
  select len;

// тип переменной result будет IEnumerable<T>, что не очень удобно, но в данном случае неотвратимо :(

// далее превратим его обратно в Maybe<T>
Maybe<T> finalResult = /* retrieve first element or get nothing */;

// в результате finalResult.HasValue == true и _value == len в случае, если и x, и y имели значение, иначе result == Maybe<T>.Nothing
```

Осталось лишь добавить метод-расширение `ToMaybe` в `MaybeExtensions`, который будет разворачивать `IEnumerable<T>` обратно в `Maybe<T>`, т.е.:

`ToMaybe<IEnumerable<T>>: IEnumerable<T> --> Maybe<T>`

Оказывается, обычным `FirstOrDefault()` или `SingleOrDefault()` это не сделаешь, т.к. для значимых типов мы не сможем потом распознать ситуацию `OrDefault`. Так что придется поиграться с итераторами последовательностей - вручную итерироваться на первый элемент и, в случае успеха, собирать `Maybe<T>`, либо отдавать `Maybe<T>.Nothing`. Отправляйся в `MaybeExtensions` и реализуй соответствующий экстеншн.

После того, как реализуешь оставшийся без реализации метод в `MaybeChef`, проверь его работоспособность и поиграйся с LINQ-синтаксисом. И снова в `Program.cs` текущего проекта тебя ждет небольшая заготовка. Как наиграешься, возвращайся.

### Feeling guilty

Согласись, вся эта пляска с `IEnumerable<T>` выглядит так себе. С одной стороны, конечно, круто - мы реализовали всего два метода интерфейса `IEnumerable<T>` и получили полную поддержку синтаксиса LINQ-запросов. С другой стороны очевидно, что такое лучше никому не показывать :)

Чтобы не чувствовать стыд за свой код, попробуем добиться поддержки синтаксиса LINQ-запросов другим способом.

## CallMeMaybe.Final & CallMeMaybe

Данная часть задачи разбита аж на два проекта:

- `CallMeMaybe` - это библиотека классов, содержащая только финальную реализацию структуры `Maybe<T>` (есть вероятность, что мы про неё ещё вспомним в следующих лабах)
- `CallMeMaybe.Final` - консольное приложение с финальной версией `MaybeChef`.

### Я там раньше соврал

Как я уже отмечал, первая версия `Maybe<T>` по некоторой случайности тоже отчасти поддерживало синтаксис запросов. Ради интереса вернись в `Program.cs` соответствующего проекта и попробуй следующий запрос:

```cs
var testingFrom = from x in 10.ToMaybe() select x + 10;
Console.WriteLine($"type: {testingFrom.GetType}; value: {testingFrom}");
```

Этот кусок кода нормально скомпилируется, а тип переменной `testingFrom` ожидаемо будет `Maybe<int>`, а значение `20`.

Так в чем же дело? А в том, что данный запрос будет заменен компилятором на следующий код (кстати, Resharper, например, умеет по команде конвертировать один синтаксис в другой):

```cs
var testingFrom = 10
    .ToMaybe()
    .Select(x => x + 10);
```

По счастливой случайности в текущей версии структуры `Maybe<T>` реализован метод `Select` с подходящей сигнатурой - поэтому все нормально компилируется и исполняется. Это что же получается, весь синтаксис LINQ-запросов - это обычный синтаксический сахар над синтаксисом `LINQ method chaining`? Yup!

И этот синтаксис нужен (=удобен) по сути только для случаев, когда `method chaining` оказывается чересчур громоздким и непонятным. А он оказывается таковым в подобных случаях:

```cs
var res =
    from x in 4.ToMaybe()
    from y in 3.ToMaybe()
    from z in 5.ToMaybe()
    where x + y > z
    select new {x, y, z};
```

, что равносильно следующему

```cs
var res = 4
    .ToMaybe()
    .SelectMany(x => 3.ToMaybe(), (x, y) => new {x, y})
    .SelectMany(t => 5.ToMaybe(), (t, z) => new {t, z})
    .Where(t => t.t.x + t.t.y > t.z)
    .Select(t => new {t.t.x, t.t.y, t.z});
```

А если брать конкретно пример из `MaybeChef`, то масштаб проблемы чуть яснее:

```cs
var eggsMixture =
    from pumpkinPieFilling in _cookingTable.FindCansOf<PumpkingPieFilling>(1m).ToMaybe()
    from sugar in _cookingTable.FindCupsOf<WhiteSugar>(3m).ToMaybe()
    from oil in _cookingTable.FindCupsOf<VegetableOil>(0.5m).ToMaybe()
    from water in _cookingTable.FindCupsOf<Water>(0.5m).ToMaybe()
    from eggs in _cookingTable.FindSome<Egg>(4m).ToMaybe()
    from eggsMixture in _cookingTable.FindBowlAndFillItWith(new EggsMixture()).ToMaybe()
    select eggsMixture;
```

равносильно

```cs
var eggsMixture = _cookingTable
    .FindCansOf<PumpkingPieFilling>(1m).ToMaybe()
    .SelectMany(
        pumpkinPieFilling => _cookingTable.FindCupsOf<WhiteSugar>(3m).ToMaybe(),
        (pumpkinPieFilling, sugar) => new {pumpkinPieFilling, sugar}
    )
    .SelectMany(t => _cookingTable.FindCupsOf<VegetableOil>(0.5m).ToMaybe(), (t, oil) => new {t, oil})
    .SelectMany(t => _cookingTable.FindCupsOf<Water>(0.5m).ToMaybe(), (t, water) => new {t, water})
    .SelectMany(t => _cookingTable.FindSome<Egg>(4m).ToMaybe(), (t, eggs) => new {t, eggs})
    .Select(t => _cookingTable.FindBowlAndFillItWith(new EggsMixture()).ToMaybe());
```

Думаю, ты заметил[-а], что как только появляется цепочка `from`, этот код разворачивается в цепочку вызовов `SelectMany`. Такого метода в первой версии нет, поэтому все подобные запросы уже не скомпилируются. Что же, давай добавим поддержку для такого рода запросов.

### Enable LINQ-query syntax

Возвращайся обратно в проекты `CallMeMaybe.Final` и `CallMeMaybe`. Как ты уже понял[-а], для полной поддержки синтаксиса запросов придется просто добавить реализации пачки методов с ожидаемыми компилятором названиями и сигнатурами. Дабы не рехнуться от всего зоопарка этих методов, а лишь надкусить вишенку этого прекрасного LINQ-тортика, реализуем пару перегрузок методов `Select`, `SelectMany` и `Where`. Этого с лихвой хватит, чтобы понять общий принцип.

В структуре `Maybe<T>` данного проекта ты найдешь заготовки соответствующих методов плюс заготовки методов, которые ты уже реализовал[-а] в первой части. Скопипасть то, что уже реализовано и добавь реализации новых методов. Затем доведи `MaybeChef` до рабочего состояния.

Теперь можешь поиграться и потестировать все, что ты тут понаделал[-а] :)

## Outro

Поздравляю с окончанием этого бесконечного задания (это я себя поздравляю, если что :)

Надеюсь, теперь тебе не страшны дженерики, лямбды, экстэншны и синтаксис LINQ-запросов.

Го пуллреквестить! Я не создал, у меня лапки.

P.S. Кстати, приведенный в примере рецепт тыквенных маффинов настоящий. Если хочется самому попытать счастье в реализации интерфейса `IOneRecipeChef` на настоящей кухне, то вот ссылочка на [него](http://allrecipes.com/recipe/234646/pumpkin-pie-muffins/) ;)

P.P.S. Сама идея про монаду _maybe_ пришла из опыта - на одном из предыдущих мест работы мы использовали библиотечку [Functional.Maybe](https://github.com/AndreyTsvetkov/Functional.Maybe). В целом местами она была весьма в тему, но не прямо как что-то такое незаменимое. При подготовке данного задания я мне так же пригодились следующие варианты реализации структуры `Maybe<T>`: [раз](https://mikhail.io/2016/01/monads-explained-in-csharp/), [два](https://github.com/hazzik/Maybe/blob/master/src/Maybe/Maybe%601.cs).