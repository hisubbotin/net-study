# 02. Primitive types

## Entry point

Рядом с этим документом расположена папка с солюшеном `AdventureTime`. Там в одноименном проекте есть файл `Time.cs`, в котором нужно реализовать методы с заглушками. Как сделаешь их, возвращайся сюда за небольшим чтивом. Удачи с задачками!

## _Хозяйке на заметку_

Ну и наконец моя любимая рубрика. _Описываемое ниже возможно не стоит пытаться запомнить в деталях, обрати внимание на саму суть проблемы и ее наличие._

Надеюсь, что длинный пример с длительностью путешествия героев Adventure Time убедил тебя, что со временем шутки плохи. В ранних версиях фреймворка работа с ним, используя только стандартные средства, была большой проблемой. В связи с этим появились различные 3rd party библиотеки, одна из них - уже упомянутая Noda Time (переработанный аналог Joda Time из Java мира).

Несмотря на то, что с приходом `DateTimeOffset` и `TimeZoneInfo` большинство проблем фреймворка решилось, решение это довольно своеобразное. Итак, с одной стороны, мы имеем всего две структуры для представления времени: `DateTime` и `DateTimeOffset` - все просто! Нет, все вообще не просто!

### DateTime

`DateTime` имеет вид `Kind`, который путает всё на свете.

#### `DateTimeKind.Utc`

Этот вид означает, что мы считаем время в "абсолютной" системе координат (aka UTC), с ним все хорошо. В целом, тип `DateTime` достаточно удобен для работы _только в UTC_. Проблема в том, что есть еще два вида (о них ниже), и ты должен проконтролировать, что на всех этапах работы со временем, вид будет выставлен правильно. Например, об этом стоит помнить при сериализации/десериализации данных тела HTTP-запроса или данных из БД.

Короче, все норм, но необходима внимательность, что уже, вообще говоря, выглядит отличным кандидатом на нечаянно накосячить.

#### `DateTimeKind.Local`

Этот вид - волк в овечьей шкуре, говорящий, что мы рассматриваем время как локальное. Но что это значит?

Думаешь, часовой пояс, в котором ты находишься и в котором находятся часы на стене в соседней комнате?

Очевидно, что нет - оно выражает "выставленное" локальное время системы и может быть каким угодно! Можешь погуглить недавний прокол команды `Snapchat`, чей таймер запуска какой-то новой фичи можно было обдурить простым переводом часового пояса на клиенте.

Представим, что локальное время выставили, менять не планируют, а измерения производятся только на этой машине - проблем ведь не будет? Не будет, пока не произойдет перевод стрелок назад с летнего времени на обычное, и линейность обозримого времени будет нарушена.

Если приложение работает на нескольких машинах (например, в облаке) и требуется сравнивать время (например, для сортировки), полученного на разных машинах - использование `DateTimeKind.Local` превращается в тикающую бомбу. Хорошая новость - не всегда это так уж критично, плохая - привычка забивать на особенности учета времени может усыпить бдительность в случаях, когда забивать уже не стоит.

На всякий случай, если было не очевидно: `DateTime.Now` - это не твой бро! У него очень-очень-очень узкое множество возможных применений.

#### `DateTimeKind.Unspecified`

Как бы это странно не звучало, но это самый близкий к "локальному" вид времени. Данный вид не пытается провернуть никакую неявную магию и просто представляет из себя каким-то образом "наблюдаемое" время. Ты задал время `"08.04.1990 18:43:21.921"` - оно ничего не говорит о том, где наблюдалось, однако саму точку на абстрактной оси координат задает, и это можно использовать! Например, если параллельно держать информацию, в каком часовом поясе наблюдалось это время.

Тем не менее и с этим видом есть маленькая проблема - наличие других видов (довольно смешно и грустно смотреть, как они отлично друг другу мешаются) и явные/неявные преобразования между ними. Например, следующие методы `DateTime`:

- `ToUniversalTime()` рассматривает `Unspecified` как вид, выражающий локальное время,
- `ToLocalTime()` наоборот рассматривает его как вид, выражающий время UTC.

Это фантастика какая-то, не правда ли? :)

### У нас же есть еще `DateTimeOffset`

Да, на первый взгляд он клевый - значение `DateTimeOffset` представляет собой точку на оси времени в абсолютной системе координат (UTC). Хранится же информация в виде связки локальное время + смещения относительно UTC (в минутах). Никаких видов, а значит и недоразумений с ними!

Но и с этим типом есть проблемы - сдвиг относительно UTC, к сожалению, ничего не говорит нам о часовом поясе. Например, существует множество часовых поясов со смещением +3. Более того, это множество непостоянно во времени (например, из-за летнего времени). Поэтому, например, на основании одного лишь значения `DateTimeOffset` невозможно сказать, каким будет локальное время через 10 минут или каким оно было 10 минут назад (например, опять же из-за летнего времени). Ну и, естественно, никакой проверки на валидность указанного локального времени не производится.

Получается, что данный тип подходит для представления абсолютного времени - из-за отстутствия видов он проще `DateTime`, но при этом тогда теряется необходимость в смещении (если нас будет интересовать только абсолютное время UTC, то помнить смещение не обязательно). Для представления же абсолютного времени **и** одновременно с ним "какого-то" локального - тоже.

А вот для работы с временем в конкретных часовых поясах придется использовать его в связке с информацией о зоне `TimeZoneInfo`, что уже несколько неудобно:

- в связке `DateTimeOffset` + `TimeZoneInfo` теряется смысл смещения у первого, т.к. информация о нем содержится во втором
- связка `DateTime` + `TimeZoneInfo` подходит лучше, но у первого вездесущие виды (`Kind`).

Еще не разочаровались в этом мире? Тогда продолжим

### Даты и время дня

Для некоторых задач интерес представляет только дата (день) без уточнения времени дня. Для этого в `.Net` предлагается использовать свойство `Date` у `DateTime`, что вроде как неплохо. По крайней мере до тех пор, пока вы случайно не забудете про [да, опять!] `Kind`, и конвертация не приведет к тому, что дата поменяется! Дело в том, что дата в `DateTime` это по сути точка времени в полночь этого дня, т.е. `08.04.1990` это `"08.04.1990 00:00:00.000"`. Если будет случайная конвертация вида, эта точка времени может стать какой-нибудь такой - `"07.04.1990 21:00:00.000"`. Еще одна стрела в чьем-то колене :)

Для времени дня же предлагается использовать `TimeSpan`, который выражает [ориентированную] длительность произвольного промежутка времени [в милисекундах]. Т.е. это относительная величина и она вполне ожидаемо может быть отрицательной. Время дня по своей природе является абсолютным значением (это не сдвиг относительно начала дня). Однако с помощью `TimeSpan` _можно_ выразить время дня, хотя семантически это не очень верно, плюс никто за тебя не проверит переполнение 24-часового отрезка и неотрицательность.

### Короче, Склифосовский

Ну и вишенкой на этом торте является то, что названия обоих типов не несут никакой информации о том, какая семантика скрыта в значении, которое в них положили. Тем самым, как я уже сказал в начале рубрики, все выглядит на первый взгляд просто, что, конечно, солидный плюс (и я серьезно!). Если бы этот плюс не маскировал кучу описанных выше проблем.

В задании я привел пример с использованием библиотеки `Noda Time`. Подход в данной библиотеке хорош тем, что разные семантики использования и трактовки времени, дат и т.п. имеют четкое и однозначное представление. Поэтому их много, поэтому с ходу все выглядит сложно и запутанно. К сожалению, время и его исчисление само по себе сложно и запутанно. Тем не менее, проблемы не маскируются, наоборот - библиотека своим апи стремится заставить тебя делать обдуманные и взвешенные решения, выбирая нужный тип в зависимости от семантики твоего случая. В конечном итоге такой подход минимизирует вероятность скрытых случайных ошибок.

**TL;DR**

1. Время и его исчисление само по себе сложно и запутано. Про это нужно помнить и не закрывать на это глаза.
1. Усложнять на ровном месте, правда, тоже не стоит. KISS
1. Главное - знать и помнить о проблеме.

**P.S.** Данная рубрика была создана на основании следующего [анализа](http://blog.nodatime.org/2011/08/what-wrong-with-datetime-anyway.html) Джона Скита, создателя библиотеки `Noda Time`.