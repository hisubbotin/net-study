/*
    Здесь все то же самое.
*/

using System;

namespace Numbers
{
    public static class FloatNumbers
    {
        /// <summary>
        /// Возвращает вещественнозначное число со значением "не число" (Not a number).
        /// </summary>
        internal static double GetNaN()
        {
            /*
                Необходимо вернуть значение, не используя непосредственно саму константу.
                Для этого подумай, какой смысл в себе несет эта константа и где бы она могла стать результатом операции или вычисления функции.
            */
            return 0.0 / 0.0;
        }

        /// <summary>
        /// Возвращает результат проверки, имеет ли указанное вещественнозначное число значение "не число" (Not a number).
        /// </summary>
        /// <param name="d">Проверяемое вещественнозначное число.</param>
        /// <returns>True, если число имеет значение "не число", иначе false.</returns>
        internal static bool IsNaN(double d)
        {
            // Подсказка: по аналогии с константами типа int, у типа double тоже есть свой набор констант.

            /*
             * Разве использование
             *  ```cs
             * return (d == Double.NaN);
             *  ```
             *  не является некорректным?
             */
            return Double.IsNaN(d);
        }
        
        /// <summary>
        /// Возвращает результат сравнения двух вещественнозначных чисел.
        /// </summary>
        /// <returns>-1 - первое меньше второго, 0 - значения равны, 1 - первое больше второго.</returns>
        internal static int Compare(double a, double b)
        {
            /*
                Подумай, почему это задание дано в части про вещественнозначные числа. И почему не дана полная сигнатура метода.
                Если сходу идей нет, перестань искать подвох и просто реализуй дословно. Теперь еще раз посмотри на код и подумай в чем может быть проблема, сколько должно быть аргументов.
            */

            /*
             * Не уверен, но могу предложить два объяснения:
             *  - Проблемы с равенством чисел с плавающей точкой - из-за погрешности равенство может не быть достигнуто.
             * В таком случае можно использовать `decimal`, но поскольку условие задания сформулировано как работа именно
             * с `double`, я всё-таки поставил в сигнатуре `double`.
             *  - Неочевидтное поведение сравнений крайних значений. Например, `(0 / 0.0) == Double.NaN`, насколько я понял,
             * возвращает `false`. У `Int32` таких значений нет.
             */
            if (a.Equals(b))
            {
                return 0;
            } else if (a < b)
            {
                return -1;
            } else
            {
                return 1;
            }
        }

        // и все?!! О_о


        // и все... -_-
    }
}
