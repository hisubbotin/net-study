# Распространенные ошибки и вещи, на которые стоит обратить внимание

## 01. Primitive Types

### TryParse + throw standard Exception

```cs
/// <summary>
/// Конвертирует строковое представление числа в его 32-битное знаковое целочисленное представление.
/// </summary>
/// <param name="s">Строковое представление числа.</param>
/// <returns>32-битное знаковое целочисленное представление числа.</returns>
internal static int Parse(string s)
{
    /*
        Продолжай идти простым путем -нужен метод, обратный методу ToString выше, который распарсит дефолтное строковое представление числа.
        Подсказка: у каждого примитивного типа есть набор статических методов, среди которых есть нужный.
    */
    int value;
    if (int.TryParse(s, out value)) {
        return value;
    } else {
        throw new ArgumentException("String does not contain correct integer", nameof(s));
    }
}
```

### Compare floats with default epsilon

```cs
/// <summary>
/// Возвращает результат сравнения двух вещественнозначных чисел.
/// </summary>
/// <returns>-1 - первое меньше второго, 0 - значения равны, 1 - первое больше второго.</returns>
internal static int Compare(double firstNumber, double secondNumber, double precision = 0.000001)
```

Одна из самых распространенных ошибок этого задания - снабжать последний аргумент значением по умолчанию. Подумай, почему это неправильно.

Значение по умолчанию может "использоваться всегда, когда нет никаких дополнительных требований". Но чем это значение лучше 1 тысячной или 1 миллиардной? Ты же даже не знаешь заранее какого порядка значения сравниваются. Представь, что пользователь твоего метода использует ее только для сравнения чисел порядка `1E+100`. Разница в порядке сравниваемых чисел и значения `precision` намного длиннее мантиссы, т.е. минимально возможная разница `firstNumber` и `secondNumber` больше `precision`. А это значит, что выражение `|firstNumber - secondNumber| <= precision` равнозначно `|firstNumber - secondNumber| <= 0`, т.е. `firstNumber == secondNumber`. А представь теперь, что числа наоборот порядка `1E-20` - твой метод будет возвращать, что все они равны ;)

Если пользователь разумный и задумался над подходящей для его задачи точностью, то он и так всегда будет передавать свое значение - значение по умолчанию ему будет не нужно. И более того вредно -  если он забудет где-то его передать, то компилятор даже не ругнется, а он будет думать, что везде передал свое правильное значение.
Если же пользователь не задумался об этой проблеме, то он конечно же воспользуется значением по умолчанию, чтобы не напрягаться, и будет ловить интересные ошибки из-за проблем, описанных выше.

## 02. Adventure Time!

Я все еще не согласен с `.ToLocalDateTime()`. Я надеюсь, что ты читал обсуждение этой задачи в телеграме.

Тем не менее, поясню еще раз. Я допускаю две стратегии решения:

1. По аналогии с "тремя месяцами" сказать, что задача поставлена недостаточно ясно, поэтому требуется доработка, а пока - держи `NotImplementedException` или `NotSupportedException`.
1. Попробовать додумать до наиболее частого случая - сравнения дат по паспорту.

С первой все понятно, для второй стратегии у меня лично логика такая. Разберем варианты `Kind`ов аргументов:

- `Utc` - имеет абсолютное время, но дату рождения в паспорт заносят "по местному", но мы не знаем по какому местному, поэтому имеется неразрешимая неопределенность.
- `Local` - имеет наше текущее локальное время, что вроде кажется подходящим, но на деле та же самая неопределенность, т.к. мы все еще не знаем локального времени для **того** пояса, где это значение было получено.
- `Unspecified` - дата "как есть", ровно так в паспорте записана дата рождение - без упоминания чего-либо, связанного с часовыми поясами, просто набор полей "год, месяц, день, час,...".

В таком случае `Kind == Unspecified` должен являться единственным имеющим смысл и разрешенным у аргументов данного метода. Можно еще дополнительно проверить, что у обоих аргументов TimeOfDay нулевой. На остальные кайнды логично кидать исключения.

## 04. Boring Vector

### Comments style

Если ты посмотришь комментарии в стандартной библиотеке, то увидишь, что у типов, интерфейсов, перечислений, свойств и методов (т.е. по-моему у всего комментируемого) комментарий как бы отвечает на вопрос "что оно делает?" и тем самым начинаются с глагола:

- свойство `DateTime.Now` (обрати внимание, из комментария понятно, что оно read-only):
> Gets a System.DateTime object that is set to the current date and time on this computer, expressed as the local time.
- а вот изменяемое свойство `this[int index]` интерфейса `IList<T>`:
> Gets or sets the element at the specified index.
- публичное поле `DBNull.Value`:
> Represents the sole instance of the System.DBNull class.
- класс `Array`:
> Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.
- класс атрибута `SerializableAttribute`:
> Indicates that a class can be serialized. This class cannot be inherited.
- интерфейс `IDisposable`:
> Provides a mechanism for releasing unmanaged resources.
- перечисление `GCCollectionMode`:
> Specifies the behavior for a forced garbage collection.

Единственное исключение из правил, которое я знаю, это классы исключений. Самые базовые типы исключений (их самих никогда не выбрасывают) обычно имеют комментарии в соответствии со стилем выше, а вот классы "выбрасываемых" исключений почти всегда имеют уже вид `The exception that is thrown when ...`. Сравни:

- `Exception`:
> Represents errors that occur during application execution.
- `StackOverflowException`:
> The exception that is thrown when the execution stack overflows because it contains too many nested method calls. This class cannot be inherited.

Если ты посмотришь мои комментарии в первых лабах, то заметишь, что я стараюсь следовать этим гайдлайнам. Кроме типов :( Я, честно говоря, сам до текущего момента не обращал внимание, что и к ним комменты начинаются с глагола, и писал всегда ответ на вопрос "что это?", начиная с существительного.

Тебе я тоже предлагаю им следовать. Ну или следовать другим гайдлайнам, которые тебе больше по душе. Главное, чтобы стиль был достаточно консистентным на протяжении всего твоего кода, а сами комментарии были хорошими: понятными, короткими и ёмкими.

Примеры:

- Вектор, на который необходимо домножить
- Домножаем на число
- Вектор, который нужно добавить к this
- Вернуть произведение.

Про `GetAngleBetween` - Acos
Комментарии к значениям перечисления.

### Tests

- `void Assert.Equal(double x, double y)`
- Стиль названий тестовых методов
- Про факт и теори
- Плохие входные данные в тестах. Ни у кого не была использована ни одна константа `double`.
- В идеале только один ассерт на тест и при чем простой.
- желательно проверять с результатом, а не якобы правильным вычислением результата `Assert.Equal(v.SquareLength(), x * x + y * y);` - проще ошибиться или не заметить переполнение.
- [InlineData(0, 0, 5, 5, 5)] // not working -- its correct

### Vector.ToString()

"(" + X.ToString() + "; " + Y.ToString() + ")";

### Static vs static readonly vs const

## 03. Drunk Fibonacci

### IEnumerable

- Skip и Take - это не перемотка времени :)

### Переполнение типа

> При вычислении сложения переполнение типа разрешено и всячески поощряется.

### Скобки в лямбдах

Откуда и зачем

### Итерация с помощью IEnumerator\<int>

```cs
IEnumerator<int> number = GetDrunkFibonacci().GetEnumerator();
while (true)
{
    int[] chunk = new int[16];
    for (int i = 0; i < chunk.Length; ++i)
    {
        number.MoveNext();
        chunk[i] = number.Current;
    }
    yield return chunk;
}
```