# Распространенные ошибки и вещи, на которые стоит обратить внимание

## 01. Primitive Types

### TryParse + throw standard exception

Рассмотрим такой вариант реализации одного из методов первого задания:

```cs
/// <summary>
/// Конвертирует строковое представление числа в его 32-битное знаковое целочисленное представление.
/// </summary>
/// <param name="s">Строковое представление числа.</param>
/// <returns>32-битное знаковое целочисленное представление числа.</returns>
internal static int Parse(string s)
{
    /*
        Продолжай идти простым путем -нужен метод, обратный методу ToString выше, который распарсит дефолтное строковое представление числа.
        Подсказка: у каждого примитивного типа есть набор статических методов, среди которых есть нужный.
    */
    int value;
    if (int.TryParse(s, out value)) {
        return value;
    } else {
        throw new ArgumentException("String does not contain correct integer", nameof(s));
    }
}
```

В текущем виде кто-то сделал двойную работу, по сути повторив то, что делает метод `int.Parse(string s)`. Вот если бы было известно, что делать в случае невозвожности корректно конвертировать строку в число, то да - было бы разумно воспользоваться `TryParse`.

Кстати, вот эти два варианта:

- Parse + try/catch + return defaultValue

```cs
try
{
    return int.Parse(s);
}
// обратите внимание - int.Parse может выбросить один из трех видов исключений
catch (ArgumentNullException) { }
catch (FormatException) { }
catch (OverflowException) { }

return defaultValue;
```

- TryParse + return defaultValue

```cs
return int.TryParse(s, out int result) ? result : defaultValue;
```

отличаются не только читабельностью, но и скоростью. Обработка исключений - штука затратная.

### Compare floats with default epsilon

Одна из самых распространенных ошибок этого задания - снабжать последний аргумент метода сравнения двух вещественных чисел значением по умолчанию:

```cs
/// <summary>
/// Возвращает результат сравнения двух вещественнозначных чисел.
/// </summary>
/// <returns>-1 - первое меньше второго, 0 - значения равны, 1 - первое больше второго.</returns>
internal static int Compare(double firstNumber, double secondNumber, double precision = 0.000001)
```

Причины дать аргументу значение по умолчанию:

- "Пользователь метода может не очень хорошо разбираться в предметной области, поэтому я дам аргументу значение, которое я, как эксперт в данной области, считаю хорошим в стандартном случае." Пример - коэффициенты настройки некоторого алгоритма или структуры данных. Почти всегда пользователю дается возможность вызвать метод с кастомными настройками, но при этом имеется некоторая настройка по умолчанию. При этом эта "ноубрейн" настройка будет хорошо работать для большинства.
- В подавляющем большинстве случаев метод будет вызываться именно с таким значением, т.е. логика по умолчанию подразумевает именно его. И наоборот - случай, когда пользотель захочет дать отличное от дефолтного значение, является исключительным.
- Параметр является опциональным. Тогда логично дать ему значение по умолчанию `null`.

В приведенном примере, чем значение 1e-6 лучше 1 тысячной или 1 миллиардной? Ведь абсолютно неизвестно заранее, какого порядка значения будут сравниваваться. Какое-бы значение ни было выбрано, оно не является "хорошим в большинстве случаев" и тем более ожидаемым. Не глядя, сможешь угадать, какая в чьей-то библиотеке выбрана точность для сравнения вещественных чисел?)

Представь, что пользователь твоего метода использует ее только для сравнения чисел порядка `1E+100`. Разница в порядке сравниваемых чисел и значения `precision` намного длиннее мантиссы, т.е. минимально возможная разница `firstNumber` и `secondNumber` больше `precision`. А это значит, что выражение `|firstNumber - secondNumber| <= precision` равнозначно `|firstNumber - secondNumber| <= 0`, т.е. по сути значения просто сравниваются на равенство `firstNumber == secondNumber`.

А представь теперь, что числа наоборот порядка `1E-20` - в таком случае данный метод будет возвращать, что все они равны ;)

Если пользователь разумный и задумался над подходящей для его задачи точностью, то он и так всегда будет передавать свое значение (какую-нибудь заведенную где-нибудь константу) - значение по умолчанию ему будет не нужно. Более того значение по умолчанию будет ему вредно -  если пользователь забудет где-то его передать, то компилятор не ругнется, и никто в "compile time" ошибки не заметит.

Если же пользователь не задумался об этой проблеме, то он конечно же воспользуется значением по умолчанию, чтобы не напрягаться, и будет ловить интересные ошибки из-за проблем, описанных выше.

## 02. Adventure Time!

### AreEqualBirthdays

Обсуждали в телеграме, зафиксирую здесь.

Я допускал две стратегии решения:

1. По аналогии с "тремя месяцами" сказать, что задача поставлена недостаточно ясно, поэтому требуется доработка, а пока - держи `NotImplementedException` или `NotSupportedException` (последний лучше подходит по семантике).
1. Попробовать додумать до наиболее частого случая - сравнения дат по паспорту.

С первой все понятно, для второй стратегии у меня лично логика такая. Разберем варианты `Kind`ов аргументов:

- `Utc` - имеет абсолютное время, но дату рождения в паспорт заносят "по местному", но мы не знаем по какому местному, поэтому имеется неразрешимая неопределенность.
- `Local` - имеет наше текущее локальное время, что вроде кажется подходящим, но на деле та же самая неопределенность, т.к. мы все еще не знаем локального времени для **той** таймзоны, где это значение было получено.
- `Unspecified` - дата "как есть", ровно так в паспорте записана дата рождение - без упоминания чего-либо, связанного с часовыми поясами, просто набор полей "год, месяц, день, час,...".

В таком случае `Kind == Unspecified` должен являться единственным имеющим смысл и разрешенным у аргументов данного метода. Можно еще дополнительно проверить, что у обоих аргументов TimeOfDay нулевой (т.е. добавить условие, что передается именно дата, а не время). На остальные кайнды логично кидать исключения.

### GetTotalMinutesInThreeMonths

__TL;DR__ Мораль задачи - относиться критически к заданиям. Вообще ко всему.

Петр Гежес как-то сказал (и я с ним не согласен):

> ... к счастью, в реальном мире таких задач __почти__ не бывает.

_Осторожно, цитата вырвана из контекста! ;)_

Возможно мне не везет, но в моей вселенной все с точностью наоборот. Иначе бы зачем, вообще, такая задача?

Примеры причин, по которым задачи формулируются некорректно или неоптимально:

- люди ошибаются,
- постановщик задачи может не знать того, что знаете вы,
- постановщик задачи вообще может не быть экспертом соответствующей области.

## 04. Boring Vector

### Unit tests

С одной стороны тестирование - очень обширная и сложная область с отдельной категорией специалистов. С другой - т.к. это смежная область, хорошо бы что-то про неё все же знать.

Написание тестов является довольно распространенной ахиллесовой пятой разработчиков. Как и любое новое занятие для человека, по началу оно оказывается медленным, скучным, малополезным и зачастую влекущим к еще большему геморрою. Если не развивать навык, ситуация сама по себе лучше не станет. В идеале же, конечно, умение писать хорошие тесты - очень крутой и полезный скилл. Как впрочем и многие другие, смежные с "непосредственно разработкой".

Далее под тестами будут подразумеваться именно юнит-тесты. Итак, ближе к делу - на что стоит обратить внимание.

#### xUnit: Fact & Theory

Чисто технически выглядит так, что разница лишь в том, есть ли входные параметры у тестового метода или нет. В принципе да, разработчики этого фреймворка могли бы оставить только `Theory` и поддерживать сигнатуры без входных параметров.

Тем не менее, существует разница в семантике:

- `Fact` - это инвариант, факт, который должен оставаться верным вне зависимости от входных данных. Пример: ты тестируешь что-нибудь вроде свойства идемпотентности метода (повторный вызов с теми же аргументами не меняет состояние системы и возвращает тот же результат). В таком случае абсолютно не принципиальны значения аргументов - важен лишь повторный вызов _с теми же аргументами_. Это инвариант системы и он не зависит от входных параметров.
- `Theory` - теория, которая верна для заданного множества входных значений.

Я в данном задании не обращаю внимание на правильное использование семантики. Для начала просто играемся с самим инструментарием.

#### Test naming styles

В отличие от названий обычных методов, названия тестовых методов обычно видят не в IDE, а в отчете работы системы прогона тестов. Например, у вас настроены автопрогон тестов после каждого билда, и отчет о проваленных тестах которого потом приходят по почте, в slack и т.п. В общем, обычно названия тестов видны там, где нет под рукой исходников - в таком случае на первый план выходит возможность быстро и однозначно из названия теста понять, что конкретно он тестирует.

Давай посмотрим, как можно было бы именовать тесты:

- `Test_<название тестируемого метода или функционала>`:

  - пример: `Test_SquareLength`
  - _не очевиден тестируемый сценарий_

- `Test_<название тестируемого метода или функционала>_<ожидаемый результат>`:

  - пример: `Test_Normalize_ReturnsZeroVector`
  - _не очевидно, почему и при каком сценарии возвращается ожидаемый результат_

- `Test_<название тестируемого метода или функционала>_<сценарий>_<ожидаемый результат>`:

  - пример: `Test_Normalize_ForZeroVector_ReturnsZeroVector`
  - _много служебных слов_

- небольшая оптимизация - убрать очевидный префикс, убрать лишние слова:

  - формат: `<тестируемый метод>_<сценарий>_<ожидаемый результат>`
  - примеры:

    - `Normalize_ZeroVector_Returns_ZeroVector`
    - `Normalize_NonZeroVector_Returns_VectorWithLengthEqualsOne`
    - `IntParse_NonDigitalString_Throws_FormatException`

- GivenWhenThen-style (GWT) - `Given_<начальное состояние>_When_<операция>_Then_<ожидаемый результат>`:

    `Given_ZeroVector_When_CallNormalize_Then_GetZeroVector`
    `Given_NonDigitalString_When_CallIntParse_Then_FormatExceptionIsThrown` (_возможно слишком "говорливый" стиль именования, больше подходит для "behavior tests"_)

Основные советы:

- придерживайся единого стиля внутри команды
- найди золотую середину подробности названия.

#### Common mistakes

Просто общие моменты:

- тестируй следование контракту, не правильность текущей реализации (т.е. будто ты не знаешь реализацию).
- твоя задача сломать тестируемый кусок, а не подтвердить, что он якобы без багов. В домашках во входных данных я не увидел ни одной стандартной константы `double` ;)
- лучше 0 тестов, чем много плохих.
- много похожих вариаций входных данных - бессмысленно. Каждый набор входных данных должен покрывать какое-то семейство входных данных.
- один тест - проверка одного контракта.
- правильно работающая система должна проходить код. _Ира, вот так не нужно делать:_

  `[InlineData(0, 0, 5, 5, 5)] // not working -- its correct`

- проверяй с результатом, а не якобы правильным вычислением результата:

  `Assert.Equal(v.SquareLength(), x * x + y * y);` - так проще ошибиться или не заметить переполнение.

- `Assert.Equal` имеет перегрузку `void (double x, double y, int precision)` - для сравнения вещественных чисел лучше пользоваться ей.

### Comments style

Если ты посмотришь комментарии в стандартной библиотеке, то увидишь, что у типов, интерфейсов, перечислений, свойств и методов (т.е. по-моему у всего комментируемого) комментарий как бы отвечает на вопрос "что оно делает?" и тем самым начинаются с глагола:

- свойство `DateTime.Now` (обрати внимание, из комментария понятно, что оно read-only):
> Gets a System.DateTime object that is set to the current date and time on this computer, expressed as the local time.
- а вот изменяемое свойство `this[int index]` интерфейса `IList<T>`:
> Gets or sets the element at the specified index.
- публичное поле `DBNull.Value`:
> Represents the sole instance of the System.DBNull class.
- класс `Array`:
> Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.
- класс атрибута `SerializableAttribute`:
> Indicates that a class can be serialized. This class cannot be inherited.
- интерфейс `IDisposable`:
> Provides a mechanism for releasing unmanaged resources.
- перечисление `GCCollectionMode`:
> Specifies the behavior for a forced garbage collection.

Единственное исключение из правил, которое я знаю, это классы исключений. Самые базовые типы исключений (их самих никогда не выбрасывают) обычно имеют комментарии в соответствии со стилем выше, а вот классы "выбрасываемых" исключений почти всегда имеют уже вид `The exception that is thrown when ...`. Сравни:

- `Exception`:
> Represents errors that occur during application execution.
- `StackOverflowException`:
> The exception that is thrown when the execution stack overflows because it contains too many nested method calls. This class cannot be inherited.

Если ты посмотришь мои комментарии в первых лабах, то заметишь, что я стараюсь следовать этим гайдлайнам. Кроме типов :( Я, честно говоря, сам до текущего момента не обращал внимание, что и к ним комменты начинаются с глагола, и писал всегда ответ на вопрос "что это?", начиная с существительного.

Тебе я тоже предлагаю им следовать. Ну или следовать другим гайдлайнам, которые тебе больше по душе. Главное, чтобы стиль был достаточно консистентным на протяжении всего твоего кода, а сами комментарии были хорошими: понятными, короткими и ёмкими.

Примеры:

- Вектор, на который необходимо домножить
- Домножаем на число
- Вектор, который нужно добавить к this
- Вернуть произведение.

Про `GetAngleBetween` - Acos
Комментарии к значениям перечисления.

### Vector.ToString()

Сравни:

```cs
return $"({x}; {y})";
```

```cs
return string.Format("({0}; {1})", x, y);
```

```cs
return "(" + x.ToString() + "; " + y.ToString() + ")";
```

### Static vs static readonly vs const

Данная переменная изменяема, а по смыслу она константа. Для значимых типов так и пишут

`private const double Epsilon = 1e-6;`.

Ссылочные типы константами не сделаешь кроме:

- типа `string`:
    ```cs 
    const string s = "abc";
    ```
- инициализации null'ом, т.е. для любого ссылочного типа константа может быть только пустая:
    ```cs
    const SomeReferenceType someInstance = null;
    ```

Поэтому для ссылочных типов самый близкий аналог констант это `static readonly`.

### Mutable structs

Представь себе такой код:

```cs
var vectors = new[] {
    new Vector(10, 20),
    new Vector(-5, 5)
};

var shift = new Vector(42, 300);
foreach (var v in vectors)
{
    Console.WriteLine(v);   // v
    var u = v.Add(shift);
    Console.WriteLine(v);   // v + shift
    Console.WriteLine(u);   // v + shift
    Console.WriteLine();
}
Console.WriteLine("=====");

foreach (var v in vectors)
{
    Console.WriteLine(v);   // v!!!
}
Console.WriteLine("=====");

for (int i = 0; i < vectors.Length; i++)
{
    Console.WriteLine(vectors[i]);  // old vectors[i]

    Console.WriteLine(vectors[i].Add(shift));   // vectors[i] + shift
    Console.WriteLine(vectors[i]);  // vectors[i] + shift

    var v = vectors[i];
    Console.WriteLine(v.Add(shift));    // vectors[i] + 2 * shift
    Console.WriteLine(vectors[i]);      // vectors[i] + shift
    Console.WriteLine();
}
```

Это один из примеров случая, когда изменяемость значимых типов влечет к не очень ожидаемому поведению.  И таких примеров на самом деле достаточно много. Отсюда пошло "mutable structs are evil". Это как голые указатели в плюсах. Иногда просто вынужден их использовать, но в большинстве случаев выгоднее обойтись чем-то попроще. В данном случае это неизменяемые структуры.

А вот второй пример:

```cs
var v = new Vector(1, 1);   // v = (1; 1)
var u = v.Scale(-1);        // u = v = (-1; -1)
var w = u.Scale(-5);        // u = w = (5, 5) != v = (-1, -1)

Console.WriteLine(v);       // (-1; -1) !!!
Console.WriteLine(u);       // (5, 5)
Console.WriteLine(w);       // (5, 5)
```

Надеюсь, я тебя немного убедил? Перепиши структуру так, чтобы она была неизменяемой, и каждая операция возвращала новый объект.

Изменяемые структуры имеют право на жизнь, иначе бы их на уровне языка уже давно запретили, но за это приходится расплачиваться заметно более высокими требованиями к концентрации внимания, покрытию кода тестами и пр.

## 03. Drunk Fibonacci

### IEnumerable

- Skip и Take - это не перемотка времени :)

### Переполнение типа

> При вычислении сложения переполнение типа разрешено и всячески поощряется.

### Скобки в лямбдах

Откуда и зачем

### Итерация с помощью IEnumerator\<int>

```cs
IEnumerator<int> number = GetDrunkFibonacci().GetEnumerator();
while (true)
{
    int[] chunk = new int[16];
    for (int i = 0; i < chunk.Length; ++i)
    {
        number.MoveNext();
        chunk[i] = number.Current;
    }
    yield return chunk;
}
```