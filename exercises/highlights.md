# Распространенные ошибки и вещи, на которые стоит обратить внимание

<!-- TOC -->

- [Распространенные ошибки и вещи, на которые стоит обратить внимание](#распространенные-ошибки-и-вещи-на-которые-стоит-обратить-внимание)
  - [01. Primitive Types](#01-primitive-types)
    - [TryParse + throw standard exception](#tryparse--throw-standard-exception)
    - [Compare floats with default epsilon](#compare-floats-with-default-epsilon)
  - [02. Adventure Time!](#02-adventure-time)
    - [AreEqualBirthdays](#areequalbirthdays)
    - [GetTotalMinutesInThreeMonths](#gettotalminutesinthreemonths)
  - [04. Boring Vector](#04-boring-vector)
    - [Unit tests](#unit-tests)
      - [xUnit: Fact & Theory](#xunit-fact--theory)
      - [Test naming styles](#test-naming-styles)
      - [Common mistakes](#common-mistakes)
    - [Comments style](#comments-style)
    - [Vector.ToString()](#vectortostring)
    - [Static vs static readonly vs const](#static-vs-static-readonly-vs-const)
    - [Mutable structs](#mutable-structs)
    - [Immutable types, field and properties](#immutable-types-field-and-properties)
      - [Что такое поля и что такое свойства](#что-такое-поля-и-что-такое-свойства)
      - [Авто-свойства](#авто-свойства)
      - [Неизменяемый объект](#неизменяемый-объект)
  - [03. Drunk Fibonacci](#03-drunk-fibonacci)
    - [IEnumerable](#ienumerable)
    - [Переполнение типа](#переполнение-типа)
    - [Итерация с помощью IEnumerator\<int>](#итерация-с-помощью-ienumerator\int)

<!-- /TOC -->

## 01. Primitive Types

### TryParse + throw standard exception

Рассмотрим такой вариант реализации одного из методов первого задания:

```cs
/// <summary>
/// Конвертирует строковое представление числа в его 32-битное знаковое целочисленное представление.
/// </summary>
/// <param name="s">Строковое представление числа.</param>
/// <returns>32-битное знаковое целочисленное представление числа.</returns>
internal static int Parse(string s)
{
    /*
        Продолжай идти простым путем -нужен метод, обратный методу ToString выше, который распарсит дефолтное строковое представление числа.
        Подсказка: у каждого примитивного типа есть набор статических методов, среди которых есть нужный.
    */
    int value;
    if (int.TryParse(s, out value)) {
        return value;
    } else {
        throw new ArgumentException("String does not contain correct integer", nameof(s));
    }
}
```

В текущем виде кто-то сделал двойную работу, по сути повторив то, что делает метод `int.Parse(string s)`. Вот если бы было известно, что делать в случае невозвожности корректно конвертировать строку в число, то да - было бы разумно воспользоваться `TryParse`.

Кстати, вот эти два варианта:

- Parse + try/catch + return defaultValue

```cs
try
{
    return int.Parse(s);
}
// обратите внимание - int.Parse может выбросить один из трех видов исключений
catch (ArgumentNullException) { }
catch (FormatException) { }
catch (OverflowException) { }

return defaultValue;
```

- TryParse + return defaultValue

```cs
return int.TryParse(s, out int result) ? result : defaultValue;
```

отличаются не только читабельностью, но и скоростью. Обработка исключений - штука затратная.

### Compare floats with default epsilon

Одна из самых распространенных ошибок этого задания - снабжать последний аргумент метода сравнения двух вещественных чисел значением по умолчанию:

```cs
/// <summary>
/// Возвращает результат сравнения двух вещественнозначных чисел.
/// </summary>
/// <returns>-1 - первое меньше второго, 0 - значения равны, 1 - первое больше второго.</returns>
internal static int Compare(double firstNumber, double secondNumber, double precision = 0.000001)
```

Причины дать аргументу значение по умолчанию:

- "Пользователь метода может не очень хорошо разбираться в предметной области, поэтому я дам аргументу значение, которое я, как эксперт в данной области, считаю хорошим в стандартном случае." Пример - коэффициенты настройки некоторого алгоритма или структуры данных. Почти всегда пользователю дается возможность вызвать метод с кастомными настройками, но при этом имеется некоторая настройка по умолчанию. При этом эта "ноубрейн" настройка будет хорошо работать для большинства.
- В подавляющем большинстве случаев метод будет вызываться именно с таким значением, т.е. логика по умолчанию подразумевает именно его. И наоборот - случай, когда пользотель захочет дать отличное от дефолтного значение, является исключительным.
- Параметр является опциональным. Тогда логично дать ему значение по умолчанию `null`.

В приведенном примере, чем значение 1e-6 лучше 1 тысячной или 1 миллиардной? Ведь абсолютно неизвестно заранее, какого порядка значения будут сравниваваться. Какое-бы значение ни было выбрано, оно не является "хорошим в большинстве случаев" и тем более ожидаемым. Не глядя, сможешь угадать, какая в чьей-то библиотеке выбрана точность для сравнения вещественных чисел?)

Представь, что пользователь твоего метода использует ее только для сравнения чисел порядка `1E+100`. Разница в порядке сравниваемых чисел и значения `precision` намного длиннее мантиссы, т.е. минимально возможная разница `firstNumber` и `secondNumber` больше `precision`. А это значит, что выражение `|firstNumber - secondNumber| <= precision` равнозначно `|firstNumber - secondNumber| <= 0`, т.е. по сути значения просто сравниваются на равенство `firstNumber == secondNumber`.

А представь теперь, что числа наоборот порядка `1E-20` - в таком случае данный метод будет возвращать, что все они равны ;)

Если пользователь разумный и задумался над подходящей для его задачи точностью, то он и так всегда будет передавать свое значение (какую-нибудь заведенную где-нибудь константу) - значение по умолчанию ему будет не нужно. Более того значение по умолчанию будет ему вредно -  если пользователь забудет где-то его передать, то компилятор не ругнется, и никто в "compile time" ошибки не заметит.

Если же пользователь не задумался об этой проблеме, то он конечно же воспользуется значением по умолчанию, чтобы не напрягаться, и будет ловить интересные ошибки из-за проблем, описанных выше.

## 02. Adventure Time!

### AreEqualBirthdays

Обсуждали в телеграме, зафиксирую здесь.

Я допускал две стратегии решения:

1. По аналогии с "тремя месяцами" сказать, что задача поставлена недостаточно ясно, поэтому требуется доработка, а пока - держи `NotImplementedException` или `NotSupportedException` (последний лучше подходит по семантике).
1. Попробовать додумать до наиболее частого случая - сравнения дат по паспорту.

С первой все понятно, для второй стратегии у меня лично логика такая. Разберем варианты `Kind`ов аргументов:

- `Utc` - имеет абсолютное время, но дату рождения в паспорт заносят "по местному", но мы не знаем по какому местному, поэтому имеется неразрешимая неопределенность.
- `Local` - имеет наше текущее локальное время, что вроде кажется подходящим, но на деле та же самая неопределенность, т.к. мы все еще не знаем локального времени для **той** таймзоны, где это значение было получено.
- `Unspecified` - дата "как есть", ровно так в паспорте записана дата рождение - без упоминания чего-либо, связанного с часовыми поясами, просто набор полей "год, месяц, день, час,...".

В таком случае `Kind == Unspecified` должен являться единственным имеющим смысл и разрешенным у аргументов данного метода. Можно еще дополнительно проверить, что у обоих аргументов TimeOfDay нулевой (т.е. добавить условие, что передается именно дата, а не время). На остальные кайнды логично кидать исключения.

### GetTotalMinutesInThreeMonths

__TL;DR__ Мораль задачи - относиться критически к заданиям. Вообще ко всему.

Петр Гежес как-то сказал (и я с ним не согласен):

> ... к счастью, в реальном мире таких задач __почти__ не бывает.

_Осторожно, цитата вырвана из контекста! ;)_

Возможно мне не везет, но в моей вселенной все с точностью наоборот. Иначе бы зачем, вообще, такая задача?

Примеры причин, по которым задачи формулируются некорректно или неоптимально:

- люди ошибаются,
- постановщик задачи может не знать того, что знаете вы,
- постановщик задачи вообще может не быть экспертом соответствующей области.

## 04. Boring Vector

### Unit tests

С одной стороны тестирование - очень обширная и сложная область с отдельной категорией специалистов. С другой - т.к. это смежная область, хорошо бы что-то про неё все же знать.

Написание тестов является довольно распространенной ахиллесовой пятой разработчиков. Как и любое новое занятие для человека, по началу оно оказывается медленным, скучным, малополезным и зачастую влекущим к еще большему геморрою. Если не развивать навык, ситуация сама по себе лучше не станет. В идеале же, конечно, умение писать хорошие тесты - очень крутой и полезный скилл. Как впрочем и многие другие, смежные с "непосредственно разработкой".

Далее под тестами будут подразумеваться именно юнит-тесты. Итак, ближе к делу - на что стоит обратить внимание.

#### xUnit: Fact & Theory

Чисто технически выглядит так, что разница лишь в том, есть ли входные параметры у тестового метода или нет. В принципе да, разработчики этого фреймворка могли бы оставить только `Theory` и поддерживать сигнатуры без входных параметров.

Тем не менее, существует разница в семантике:

- `Fact` - это инвариант, факт, который должен оставаться верным вне зависимости от входных данных. Пример: ты тестируешь что-нибудь вроде свойства идемпотентности метода (повторный вызов с теми же аргументами не меняет состояние системы и возвращает тот же результат). В таком случае абсолютно не принципиальны значения аргументов - важен лишь повторный вызов _с теми же аргументами_. Это инвариант системы и он не зависит от входных параметров.
- `Theory` - теория, которая верна для заданного множества входных значений.

Я в данном задании не обращаю внимание на правильное использование семантики. Для начала просто играемся с самим инструментарием.

#### Test naming styles

В отличие от названий обычных методов, названия тестовых методов обычно видят не в IDE, а в отчете работы системы прогона тестов. Например, у вас настроен автопрогон тестов после каждого билда, и отчет о проваленных тестах потом приходит по почте, в slack и т.п. В таком случае скорее всего под рукой исходников у вас не окажется, а значит на первый план выходит возможность быстро и однозначно из названия теста понять, что конкретно он тестирует.

Давай посмотрим, как можно было бы именовать тесты:

- `Test_<название тестируемого метода или функционала>`:

  - пример: `Test_SquareLength`
  - _не очевиден тестируемый сценарий_

- `Test_<название тестируемого метода или функционала>_<ожидаемый результат>`:

  - пример: `Test_Normalize_ReturnsZeroVector`
  - _не очевидно, почему и при каком сценарии возвращается ожидаемый результат_

- `Test_<название тестируемого метода или функционала>_<сценарий>_<ожидаемый результат>`:

  - пример: `Test_Normalize_ForZeroVector_ReturnsZeroVector`
  - _много служебных слов_

- небольшая оптимизация - убрать очевидный префикс, убрать лишние слова:

  - формат: `<тестируемый метод>_<сценарий>_<ожидаемый результат>`
  - примеры:

    - `Normalize_ZeroVector_Returns_ZeroVector`
    - `Normalize_NonZeroVector_Returns_VectorWithLengthEqualsOne`
    - `IntParse_NonDigitalString_Throws_FormatException`

- еще популярен стиль GivenWhenThen-style (GWT) - `Given_<начальное состояние>_When_<сценарий>_Then_<ожидаемый результат>`:

    - `Given_ZeroVector_When_CallNormalize_Then_GetZeroVector`
    - `Given_NonDigitalString_When_CallIntParse_Then_FormatExceptionIsThrown`
    - _возможно слишком "говорливый" стиль именования, больше подходит для "behavior tests", где желательно писать максимально естественным языком_

Основные советы:

- придерживайся единого стиля внутри команды
- найди золотую середину подробности названия.

#### Common mistakes

Просто общие моменты:

- _Тестируй следование контракту, не правильность текущей реализации (т.е. будто не знаешь реализацию)._

  Не знаю, сталкаивались ли вы с этим, но я несколько раз на собеседованиях после реализации требуемого кусочка кода буквально через секунду после просьбы "а давайте теперь напишем к вашему методу тесты" находил ошибку в своем коде - достаточно было поменять в голове роль и мыслить в ключе "как сломать этот метод". Отсюда следующий пункт.

- _Твоя задача сломать тестируемый кусок, а не подтвердить, что он якобы без багов._

  В домашках во входных данных я не увидел ни одной стандартной константы `double` ;) В том виде, в котором вы их сдавали, тесты выглядели больше как попытка убедить себя в правильности вашей реализации.

- _Лучше 0 тестов, чем много плохих._

  Любые тесты нужно писать, а потом поддерживать. И это довольно трудоемкое (и зачастую скучное) занятие.

- _Много вариаций похожих входных данных не имеет смысла._

  Каждый набор входных данных должен покрывать какое-то семейство входных данных.

- _Один тест - проверка одного контракта._

  Проще писать, проще читать, проще менять, проще локализовать проблему.

- _Правильно работающая система должна проходить тесты._

  Ира, вот так делать неправильно:

  `[InlineData(0, 0, 5, 5, 5)] // not working -- its correct`

  Иначе, как после прогона тестов автоматически понять, что реализация удовлетворяет заданным контрактам.

- _Сравнивай с ожидаемым значением результата, а не якобы правильным вычислением результата._

  В вычислении проще ошибиться. Здесь, например, можно не заметить переполнение:

  `Assert.Equal(v.IntegerSquareLength(), x * x + y * y);`.

- `Assert.Equal` имеет перегрузку `void (double x, double y, int precision)` - для сравнения вещественных чисел лучше пользоваться ей.

### Comments style

Если ты посмотришь комментарии в стандартной библиотеке, то увидишь, что у типов, интерфейсов, перечислений, свойств и методов (т.е. по-моему у всего комментируемого) комментарий как бы отвечает на вопрос "что оно делает?" и тем самым начинается с глагола:

- свойство `DateTime.Now` (обрати внимание, из комментария понятно, что оно read-only):
  > Gets a System.DateTime object that is set to the current date and time on this computer, expressed as the local time.

- а вот изменяемое свойство `this[int index]` интерфейса `IList<T>`:
  > Gets or sets the element at the specified index.

- публичное поле `DBNull.Value`:
  > Represents the sole instance of the System.DBNull class.

- класс `Array`:
  > Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.

- класс атрибута `SerializableAttribute`:
  > Indicates that a class can be serialized. This class cannot be inherited.

- интерфейс `IDisposable`:
  > Provides a mechanism for releasing unmanaged resources.

- перечисление `GCCollectionMode`:
  > Specifies the behavior for a forced garbage collection.

Единственное исключение из правил, которое я знаю, это классы исключений. Базовые типы исключений, которых самих по себе никогда не выбрасывают, похоже, имеют комментарии в соответствии со стилем выше, а вот классы "выбрасываемых" исключений почти всегда имеют вид `The exception that is thrown when ...`. Сравни:

- `Exception` (это самый базовый класс исключений):
  > Represents errors that occur during application execution.

- `StackOverflowException` (исключение, которое названо в честь того-самого-сайта - его обычно выбрасывает мозг программиста после того, как не может найти на том-самом-сайте решение своей проблемы, и приходится читать кучу сложных статей, блогов и документации) :
  > The exception that is thrown when the execution stack overflows because it contains too many nested method calls. This class cannot be inherited.

Если ты посмотришь мои комментарии в первых лабах, то заметишь, что я стараюсь следовать этим гайдлайнам. Кроме типов :( Я, честно говоря, сам до текущего момента не обращал внимание, что и к ним комменты начинаются с глагола, и писал всегда ответ на вопрос "что это?", начиная с существительного.

Тебе я тоже предлагаю следовать приведенному стилю. Ну или следовать другим гайдлайнам, которые тебе больше по душе. Главное, чтобы стиль был достаточно консистентным на протяжении всего твоего кода, а сами комментарии были хорошими: понятными, короткими и ёмкими.

ниже не готово
___
Примеры:

- Вектор, на который необходимо домножить
- Домножаем на число
- Вектор, который нужно добавить к this
- Вернуть произведение.

Про `GetAngleBetween` - Acos
Комментарии к значениям перечисления.

ниже пункты не закончены
___

### Vector.ToString()

Сравни:

```cs
return $"({x}; {y})";
```

```cs
return string.Format("({0}; {1})", x, y);
```

```cs
return "(" + x.ToString() + "; " + y.ToString() + ")";
```

### Static vs static readonly vs const

Данная переменная изменяема, а по смыслу она константа. Для значимых типов так и пишут

`private const double Epsilon = 1e-6;`.

Ссылочные типы константами не сделаешь кроме:

- типа `string`:
    ```cs 
    const string s = "abc";
    ```
- инициализации null'ом, т.е. для любого ссылочного типа константа может быть только пустая:
    ```cs
    const SomeReferenceType someInstance = null;
    ```

Поэтому для ссылочных типов самый близкий аналог констант это `static readonly`.

### Mutable structs

Представь себе такой код:

```cs
var vectors = new[] {
    new Vector(10, 20),
    new Vector(-5, 5)
};

var shift = new Vector(42, 300);
foreach (var v in vectors)
{
    Console.WriteLine(v);   // v
    var u = v.Add(shift);
    Console.WriteLine(v);   // v + shift
    Console.WriteLine(u);   // v + shift
    Console.WriteLine();
}
Console.WriteLine("=====");

foreach (var v in vectors)
{
    Console.WriteLine(v);   // v!!!
}
Console.WriteLine("=====");

for (int i = 0; i < vectors.Length; i++)
{
    Console.WriteLine(vectors[i]);  // old vectors[i]

    Console.WriteLine(vectors[i].Add(shift));   // vectors[i] + shift
    Console.WriteLine(vectors[i]);  // vectors[i] + shift

    var v = vectors[i];
    Console.WriteLine(v.Add(shift));    // vectors[i] + 2 * shift
    Console.WriteLine(vectors[i]);      // vectors[i] + shift
    Console.WriteLine();
}
```

Это один из примеров случая, когда изменяемость значимых типов влечет к не очень ожидаемому поведению.  И таких примеров на самом деле достаточно много. Отсюда пошло "mutable structs are evil". Это как голые указатели в плюсах. Иногда просто вынужден их использовать, но в большинстве случаев выгоднее обойтись чем-то попроще. В данном случае это неизменяемые структуры.

А вот второй пример:

```cs
var v = new Vector(1, 1);   // v = (1; 1)
var u = v.Scale(-1);        // u = v = (-1; -1)
var w = u.Scale(-5);        // u = w = (5, 5) != v = (-1, -1)

Console.WriteLine(v);       // (-1; -1) !!!
Console.WriteLine(u);       // (5, 5)
Console.WriteLine(w);       // (5, 5)
```

Надеюсь, я тебя немного убедил? Перепиши структуру так, чтобы она была неизменяемой, и каждая операция возвращала новый объект.

Изменяемые структуры имеют право на жизнь, иначе бы их на уровне языка уже давно запретили, но за это приходится расплачиваться заметно более высокими требованиями к концентрации внимания, покрытию кода тестами и пр.

### Immutable types, field and properties

Усаживайся поудобнее, впереди длинная история.

#### Что такое поля и что такое свойства

Единственные реальные данные, которые содержат объекты классов или структур, это поля:

```cs
class Foo
{
    // это поле можно менять только внутри класса, снаружи к нему доступа нет
    private int _x;

    // это поле публично - к нему могут обращаться и менять все
    public int _x;
}
```

Поле можно сделать публичным как в примере. А еще поле можно сделать `readonly` - сказать явно, что данное поле нельзя менять после инициализации в конструкторе. Так что да, `public readonly` поле является возможным решением в нашем случае. Но не самым "идеологически верным".

Поля структур и классов являются деталью их реализации (состояния), которую по правилам ООП принято скрывать от пользователя. Для инкапсуляции полей в c# есть свойства:

```cs
class Foo
{
    private int _x;

    // это публичное свойство с публичными геттером и сеттером, а поле _x в этой ситуации
    // называют  backing field
    public int X
    {
        get { return _x; }
        set { _x = value; }
    }

    // но свойство может быть и таким
    public int StrangeX
    {
        get
        {
            Console.WriteLine("hello");
            return -1;
        }
        set
        {
            // ничего не делать
        }
    }

    // потому что по факту свойство - это лишь пара методов, на которые его заменит компилятор. Для последнего примера выше будет что-то такое:

    public int get_StrangeX()
    {
        Console.WriteLine("hello");
        return -1;
    }
    public void set_StrangeX(int value)
    {
        // ничего не делать
    }

    // и все обращения к свойству будут заменены на вызовы соответствующих методов
    // в реальности названия методов будут другими - главное, что они не известны тебе и не пересекаются с имеющимися.
}
```

Как видишь, если мы хотим следовать принципам ООП, то инкапсуляция полей в свойства требует довольно много писанины (пусть и автоматизируемой многими IDE):

```cs
// вместо того, чтобы написать просто
public int X;

// приходится писать так!
private int _x;
public int X
{
    get { return _x; }
    set { _x = value; }
}

```

#### Авто-свойства

Дабы уменьшить страдания программистов через некоторое время в C# ввели так называемые авто-свойства (auto-properties), имеющих следующий синтаксис:

```cs
public int X { get; set; }


//Данное свойство компилятор сам развернет в:

private int _x; // название поля будет какое-то уникальное и тебе неизвестное.
public int get_X() { return _x; }
public void set_X(int value) { x = value; }
```

Как видишь, писать значительно меньше. Обычно свойства именно авто-свойства, т.е. не содержат никакой логики, кроме "вернуть значение поля" и "задать новое значение полю".

Свойства, как и поля, могут иметь все четыре модификатора видимости: `public`, `internal`, `protected`, `private`. Но они не могут быть `readonly`. Потому что это не данные, а пара методов. Более того, что у обычных свойств, что у авто-свойств, геттеру и сеттеру можно давать разную видимость:

```cs
public int X
{
    get;  // публичный, т.к. свойство публично
    private set;  // а вот сеттер приватный
}
```

#### Неизменяемый объект

Давай теперь посмотрим, какие есть варианты задать координату X структуры (или класса) публичной и неизменяемой:

- public readonly field. Минусы - не по ООПшному:

```cs
public readonly int X;
```

- публичное авто-свойство с приватным сеттером. Минусы - не по-настоящему неизменяемый, т.к. внутри менять можем:

```cs
public int X { get; private set; }
```

- публичное обычное свойство с readonly backing field. Минусы - господи, сколько писать, господи, какой нелаконичный и непонятный код:

```cs
private readonly int _x;

// не авто-свойство
public int X
{
    get { return _x; }
    // сеттер у обычных свойств можно не писать
}
```

В итоге до C# 6.0 самый идеологический правильный способ сделать по-настоящему иммутабельную структуру был ооочень некрасивым и неудобным. Поэтому большинство либо забивало на ООП и выбирала первый способ, либо на "не-настоящность" неизменяемости, выбирая второй.

Ровно для устранения проблемы третьего варианта в шестых шарпах добавили get-only auto-properties:

```cs
// полный аналог третьего варианта
public int X { get; }
```

Это правильный способ задавать иммутабельные свойства, а с помощью них - иммутабельные типы.

## 03. Drunk Fibonacci

### IEnumerable

- Skip и Take - это не перемотка времени :)

### Переполнение типа

> При вычислении сложения переполнение типа разрешено и всячески поощряется.

### Итерация с помощью IEnumerator\<int>

```cs
IEnumerator<int> number = GetDrunkFibonacci().GetEnumerator();
while (true)
{
    int[] chunk = new int[16];
    for (int i = 0; i < chunk.Length; ++i)
    {
        number.MoveNext();
        chunk[i] = number.Current;
    }
    yield return chunk;
}
```