# 03. Go home, Fibonacci, you're drunk

## Entry point

Рядом с этим документом расположена папка с солюшеном `DrunkFibonacci`. Там в одноименном проекте есть файл `DrunkFibonacci.cs`, в котором нужно реализовать методы с заглушками.

## Remarks

Большая часть методов реализуется с использованием стандартных методов-расширений для работы с последовательностями и коллекциями, являющихся частью расширения `System.Linq`. Эти методы являются частью `LINQ`(Language INtegrated Query), который и был создан именно для работы с коллекциями. В `LINQ` есть два способа записи:

* `extension method chain` синтаксис, используя цепочку вызовов методов-расширений:

  ```cs
  var totalCost = orders
      .Join(
          products, // с кем джойн
          (o, p) => o.ProductId == p.Id, // по какому критерию
          (o, p) => p.Cost * o.Amount // что на выходе - стоимость заказа
      )
      .Sum(cost => cost > 1000);  // допустим хотим получить сумму заказов на сумму больше 1000 у.е.

  // или короче, если products - словарь продуктов
  var totalCost2 = orders
      .Select(o => products[o.ProductId].Cost * o.Amount)
      .Sum(cost => cost > 1000);
  ```

* декларативный `query` синтаксис, используя специальный синтаксический сахар, введенный с `LINQ`:

  ```cs
  var filteredOrders =
      from o in orders
      from p in products
      where o.ProductId = p.Id  // первыми тремя строками сделали джойн
      let cost = p.Cost * o.Amount  // так вводятся промежуточные локальные переменные
      where cost > 1000
      select new { Order = o, Product = p, Cost = cost }; // конструируем результат

  // у методов агрегации нет аналогов в `query` синтаксисе, поэтому их только первым способом
  var totalCost = filteredOrders.Sum(o => o.Cost);

  var filteredOrderCosts2 =
      from o in orders
      let cost = products[o.ProductId].Cost * o.Amount
      where cost > 1000
      select cost;

  var totalCost2 = filteredOrderCosts2.Sum();
  ```

Не смотря на то, что вроде как декларативный синтаксис был создан для более удобной и наглядной работы с коллекциями, на практике в большинстве случаев удобнее и читабельнее оказывается все же первый вариант. Обычно это вызвано тем, что в `query` синтаксисе отсутствует множество часто используемых методов, а значит приходится часть пайплайна вычислений писать, используя первый способ, и в итоге этот самый пайплайн разбивается на куски разного синтаксиса, запутывая и раздувая его.

Ну и сам по себе `method chain` синтаксис на мой взгляд и так достаточно нагляден. Обычно я придерживаюсь именно этого синтаксиса, но в некоторых случаях какие-то части пишу в `query` синтаксисе, если на мой взгляд это выглядит понятнее и/или короче.

В целом же это конечно вкусовщина, которая отчасти должна регулироваться внутренними гайдлайнами.